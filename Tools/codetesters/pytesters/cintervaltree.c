/* Generated by Cython 0.9.6.14 on Mon Mar 30 15:08:51 2009 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#if PY_VERSION_HEX < 0x02050000
  typedef int Py_ssize_t;
  #define PY_SSIZE_T_MAX INT_MAX
  #define PY_SSIZE_T_MIN INT_MIN
  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
  #define PyInt_AsSsize_t(o)   PyInt_AsLong(o)
  #define PyNumber_Index(o)    PyNumber_Int(o)
  #define PyIndex_Check(o)     PyNumber_Check(o)
#endif
#if PY_VERSION_HEX < 0x02040000
  #define METH_COEXIST 0
#endif
#ifndef __stdcall
  #define __stdcall
#endif
#ifndef __cdecl
  #define __cdecl
#endif
#ifdef __cplusplus
#define __PYX_EXTERN_C extern "C"
#else
#define __PYX_EXTERN_C extern
#endif
#include <math.h>
#include "stdlib.h"


#ifdef __GNUC__
#define INLINE __inline__
#elif _WIN32
#define INLINE __inline
#else
#define INLINE 
#endif

typedef struct {PyObject **p; char *s;} __Pyx_InternTabEntry; /*proto*/
typedef struct {PyObject **p; char *s; long n; int is_unicode;} __Pyx_StringTabEntry; /*proto*/



static int __pyx_skip_dispatch = 0;


/* Type Conversion Predeclarations */

#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static INLINE int __Pyx_PyObject_IsTrue(PyObject* x);
static INLINE PY_LONG_LONG __pyx_PyInt_AsLongLong(PyObject* x);
static INLINE unsigned PY_LONG_LONG __pyx_PyInt_AsUnsignedLongLong(PyObject* x);
static INLINE Py_ssize_t __pyx_PyIndex_AsSsize_t(PyObject* b);

#define __pyx_PyInt_AsLong(x) (PyInt_CheckExact(x) ? PyInt_AS_LONG(x) : PyInt_AsLong(x))
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))

static INLINE unsigned char __pyx_PyInt_unsigned_char(PyObject* x);
static INLINE unsigned short __pyx_PyInt_unsigned_short(PyObject* x);
static INLINE char __pyx_PyInt_char(PyObject* x);
static INLINE short __pyx_PyInt_short(PyObject* x);
static INLINE int __pyx_PyInt_int(PyObject* x);
static INLINE long __pyx_PyInt_long(PyObject* x);
static INLINE signed char __pyx_PyInt_signed_char(PyObject* x);
static INLINE signed short __pyx_PyInt_signed_short(PyObject* x);
static INLINE signed int __pyx_PyInt_signed_int(PyObject* x);
static INLINE signed long __pyx_PyInt_signed_long(PyObject* x);
static INLINE long double __pyx_PyInt_long_double(PyObject* x);
#ifdef __GNUC__
/* Test for GCC > 2.95 */
#if __GNUC__ > 2 ||               (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)) 
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
#else /* __GNUC__ > 2 ... */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ > 2 ... */
#else /* __GNUC__ */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ */
    
static PyObject *__pyx_m;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static char * __pyx_cfilenm= __FILE__;
static char *__pyx_filename;
static char **__pyx_f;

static char __pyx_mdoc[] = "\nData structure for performing intersect queries on a set of intervals which\npreserves all information about the intervals (unlike bitset projection methods).\n\n:Authors: James Taylor (james@jamestaylor.org),\n          Ian Schenk (ian.schenck@gmail.com),\n          Brent Pederson (bpederse@gmail.com)\n";

static INLINE void __Pyx_RaiseArgtupleTooLong(Py_ssize_t num_expected, Py_ssize_t num_found); /*proto*/

static int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed); /*proto*/

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list); /*proto*/

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/

static int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/

static void __Pyx_WriteUnraisable(char *name); /*proto*/

static int __Pyx_InternStrings(__Pyx_InternTabEntry *t); /*proto*/

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/

static int __Pyx_SetVtable(PyObject *dict, void *vtable); /*proto*/

static void __Pyx_AddTraceback(char *funcname); /*proto*/

/* Declarations */

typedef char *__pyx_t_13cintervaltree_char_star;

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":245
 *     ##     return [left, right]
 *     
 *     cpdef left(self, position, int n=1, int max_dist=2500):             # <<<<<<<<<<<<<< 
 *         """
 *         find n features with a start > than `position`
 */

struct __pyx_opt_args_13cintervaltree_12IntervalNode_left {
  int __pyx_n;
  int n;
  int max_dist;
};

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":260
 *         return r[:n]
 * 
 *     cpdef right(self, position, int n=1, int max_dist=2500):             # <<<<<<<<<<<<<< 
 *         """
 *         find n features with a end < than position
 */

struct __pyx_opt_args_13cintervaltree_12IntervalNode_right {
  int __pyx_n;
  int n;
  int max_dist;
};

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":60
 * cdef float nlog = -1.0 / log(0.5)
 * 
 * cdef class IntervalNode:             # <<<<<<<<<<<<<< 
 *     """
 *     A single node of an `IntervalTree`.
 */

struct __pyx_obj_13cintervaltree_IntervalNode {
  PyObject_HEAD
  struct __pyx_vtabstruct_13cintervaltree_IntervalNode *__pyx_vtab;
  float priority;
  PyObject *interval;
  int start;
  int end;
  int minend;
  int maxend;
  int minstart;
  struct __pyx_obj_13cintervaltree_IntervalNode *cleft;
  struct __pyx_obj_13cintervaltree_IntervalNode *cright;
  struct __pyx_obj_13cintervaltree_IntervalNode *croot;
};

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":287
 * ## ---- Wrappers that retain the old interface -------------------------------
 * 
 * cdef class Interval:             # <<<<<<<<<<<<<< 
 *     """
 *     Basic feature, with required integer start and end properties.
 */

struct __pyx_obj_13cintervaltree_Interval {
  PyObject_HEAD
  int start;
  int end;
  PyObject *value;
  PyObject *strand;
};

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":321
 *         return cmp( self.start, other.start ) or cmp( self.end, other.end )
 * 
 * cdef class IntervalTree:             # <<<<<<<<<<<<<< 
 *     """
 *     Data structure for performing window intersect queries on a set of 
 */

struct __pyx_obj_13cintervaltree_IntervalTree {
  PyObject_HEAD
  struct __pyx_obj_13cintervaltree_IntervalNode *root;
};


/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":60
 * cdef float nlog = -1.0 / log(0.5)
 * 
 * cdef class IntervalNode:             # <<<<<<<<<<<<<< 
 *     """
 *     A single node of an `IntervalTree`.
 */

struct __pyx_vtabstruct_13cintervaltree_IntervalNode {
  struct __pyx_obj_13cintervaltree_IntervalNode *(*insert)(struct __pyx_obj_13cintervaltree_IntervalNode *, int, int, PyObject *);
  struct __pyx_obj_13cintervaltree_IntervalNode *(*rotate_right)(struct __pyx_obj_13cintervaltree_IntervalNode *);
  struct __pyx_obj_13cintervaltree_IntervalNode *(*rotate_left)(struct __pyx_obj_13cintervaltree_IntervalNode *);
  void (*set_ends)(struct __pyx_obj_13cintervaltree_IntervalNode *);
  void (*_intersect)(struct __pyx_obj_13cintervaltree_IntervalNode *, int, int, PyObject *);
  void (*_seek_left)(struct __pyx_obj_13cintervaltree_IntervalNode *, int, PyObject *, int, int);
  void (*_seek_right)(struct __pyx_obj_13cintervaltree_IntervalNode *, int, PyObject *, int, int);
  PyObject *(*left)(struct __pyx_obj_13cintervaltree_IntervalNode *, PyObject *, struct __pyx_opt_args_13cintervaltree_12IntervalNode_left *__pyx_optional_args);
  PyObject *(*right)(struct __pyx_obj_13cintervaltree_IntervalNode *, PyObject *, struct __pyx_opt_args_13cintervaltree_12IntervalNode_right *__pyx_optional_args);
  void (*_traverse)(struct __pyx_obj_13cintervaltree_IntervalNode *, PyObject *);
};
static struct __pyx_vtabstruct_13cintervaltree_IntervalNode *__pyx_vtabptr_13cintervaltree_IntervalNode;

static PyTypeObject *__pyx_ptype_13cintervaltree_IntervalNode = 0;
static PyTypeObject *__pyx_ptype_13cintervaltree_Interval = 0;
static PyTypeObject *__pyx_ptype_13cintervaltree_IntervalTree = 0;
static float __pyx_v_13cintervaltree_nlog;
static struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_13cintervaltree_EmptyNode = 0;
static int __pyx_f_13cintervaltree_imax2(int, int); /*proto*/
static int __pyx_f_13cintervaltree_imax3(int, int, int); /*proto*/
static int __pyx_f_13cintervaltree_imin3(int, int, int); /*proto*/
static int __pyx_f_13cintervaltree_imin2(int, int); /*proto*/


/* Implementation of cintervaltree */


static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_2500;

static PyObject *__pyx_n___repr__;
static PyObject *__pyx_n___cinit__;
static PyObject *__pyx_n_insert;
static PyObject *__pyx_n_intersect;
static PyObject *__pyx_n_find;
static PyObject *__pyx_n_left;
static PyObject *__pyx_n_right;
static PyObject *__pyx_n_traverse;
static PyObject *__pyx_n___init__;
static PyObject *__pyx_n___cmp__;
static PyObject *__pyx_n_before;
static PyObject *__pyx_n_after;
static PyObject *__pyx_n_insert_interval;
static PyObject *__pyx_n_before_interval;
static PyObject *__pyx_n_after_interval;
static PyObject *__pyx_n_upstream_of_interval;
static PyObject *__pyx_n_downstream_of_interval;
static PyObject *__pyx_n_add;
static PyObject *__pyx_n_add_interval;
static PyObject *__pyx_n_operator;
static PyObject *__pyx_n_Intersecter;

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":32
 * ctypedef char * char_star
 * 
 * cdef inline int imax2(int a, int b):             # <<<<<<<<<<<<<< 
 *     if b > a: return b
 *     return a
 */

static INLINE int __pyx_f_13cintervaltree_imax2(int __pyx_v_a, int __pyx_v_b) {
  int __pyx_r;
  int __pyx_1;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":33
 * 
 * cdef inline int imax2(int a, int b):
 *     if b > a: return b             # <<<<<<<<<<<<<< 
 *     return a
 * 
 */
  __pyx_1 = (__pyx_v_b > __pyx_v_a);
  if (__pyx_1) {
    __pyx_r = __pyx_v_b;
    goto __pyx_L0;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":34
 * cdef inline int imax2(int a, int b):
 *     if b > a: return b
 *     return a             # <<<<<<<<<<<<<< 
 * 
 * cdef inline int imax3(int a, int b, int c):
 */
  __pyx_r = __pyx_v_a;
  goto __pyx_L0;

  __pyx_r = 0;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":36
 *     return a
 * 
 * cdef inline int imax3(int a, int b, int c):             # <<<<<<<<<<<<<< 
 *     if b > a: 
 *         if c > b:
 */

static INLINE int __pyx_f_13cintervaltree_imax3(int __pyx_v_a, int __pyx_v_b, int __pyx_v_c) {
  int __pyx_r;
  int __pyx_1;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":37
 * 
 * cdef inline int imax3(int a, int b, int c):
 *     if b > a:             # <<<<<<<<<<<<<< 
 *         if c > b:
 *             return c
 */
  __pyx_1 = (__pyx_v_b > __pyx_v_a);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":38
 * cdef inline int imax3(int a, int b, int c):
 *     if b > a: 
 *         if c > b:             # <<<<<<<<<<<<<< 
 *             return c
 *         return b
 */
    __pyx_1 = (__pyx_v_c > __pyx_v_b);
    if (__pyx_1) {

      /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":39
 *     if b > a: 
 *         if c > b:
 *             return c             # <<<<<<<<<<<<<< 
 *         return b
 *     if a > c:
 */
      __pyx_r = __pyx_v_c;
      goto __pyx_L0;
      goto __pyx_L3;
    }
    __pyx_L3:;

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":40
 *         if c > b:
 *             return c
 *         return b             # <<<<<<<<<<<<<< 
 *     if a > c:
 *         return a
 */
    __pyx_r = __pyx_v_b;
    goto __pyx_L0;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":41
 *             return c
 *         return b
 *     if a > c:             # <<<<<<<<<<<<<< 
 *         return a
 *     return c
 */
  __pyx_1 = (__pyx_v_a > __pyx_v_c);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":42
 *         return b
 *     if a > c:
 *         return a             # <<<<<<<<<<<<<< 
 *     return c
 * 
 */
    __pyx_r = __pyx_v_a;
    goto __pyx_L0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":43
 *     if a > c:
 *         return a
 *     return c             # <<<<<<<<<<<<<< 
 * 
 * cdef inline int imin3(int a, int b, int c):
 */
  __pyx_r = __pyx_v_c;
  goto __pyx_L0;

  __pyx_r = 0;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":45
 *     return c
 * 
 * cdef inline int imin3(int a, int b, int c):             # <<<<<<<<<<<<<< 
 *     if b < a: 
 *         if c < b:
 */

static INLINE int __pyx_f_13cintervaltree_imin3(int __pyx_v_a, int __pyx_v_b, int __pyx_v_c) {
  int __pyx_r;
  int __pyx_1;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":46
 * 
 * cdef inline int imin3(int a, int b, int c):
 *     if b < a:             # <<<<<<<<<<<<<< 
 *         if c < b:
 *             return c
 */
  __pyx_1 = (__pyx_v_b < __pyx_v_a);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":47
 * cdef inline int imin3(int a, int b, int c):
 *     if b < a: 
 *         if c < b:             # <<<<<<<<<<<<<< 
 *             return c
 *         return b
 */
    __pyx_1 = (__pyx_v_c < __pyx_v_b);
    if (__pyx_1) {

      /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":48
 *     if b < a: 
 *         if c < b:
 *             return c             # <<<<<<<<<<<<<< 
 *         return b
 *     if a < c:
 */
      __pyx_r = __pyx_v_c;
      goto __pyx_L0;
      goto __pyx_L3;
    }
    __pyx_L3:;

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":49
 *         if c < b:
 *             return c
 *         return b             # <<<<<<<<<<<<<< 
 *     if a < c:
 *         return a
 */
    __pyx_r = __pyx_v_b;
    goto __pyx_L0;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":50
 *             return c
 *         return b
 *     if a < c:             # <<<<<<<<<<<<<< 
 *         return a
 *     return c
 */
  __pyx_1 = (__pyx_v_a < __pyx_v_c);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":51
 *         return b
 *     if a < c:
 *         return a             # <<<<<<<<<<<<<< 
 *     return c
 * 
 */
    __pyx_r = __pyx_v_a;
    goto __pyx_L0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":52
 *     if a < c:
 *         return a
 *     return c             # <<<<<<<<<<<<<< 
 * 
 * cdef inline int imin2(int a, int b):
 */
  __pyx_r = __pyx_v_c;
  goto __pyx_L0;

  __pyx_r = 0;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":54
 *     return c
 * 
 * cdef inline int imin2(int a, int b):             # <<<<<<<<<<<<<< 
 *     if b < a: return b
 *     return a
 */

static INLINE int __pyx_f_13cintervaltree_imin2(int __pyx_v_a, int __pyx_v_b) {
  int __pyx_r;
  int __pyx_1;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":55
 * 
 * cdef inline int imin2(int a, int b):
 *     if b < a: return b             # <<<<<<<<<<<<<< 
 *     return a
 * 
 */
  __pyx_1 = (__pyx_v_b < __pyx_v_a);
  if (__pyx_1) {
    __pyx_r = __pyx_v_b;
    goto __pyx_L0;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":56
 * cdef inline int imin2(int a, int b):
 *     if b < a: return b
 *     return a             # <<<<<<<<<<<<<< 
 * 
 * cdef float nlog = -1.0 / log(0.5)
 */
  __pyx_r = __pyx_v_a;
  goto __pyx_L0;

  __pyx_r = 0;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":74
 * 
 *     property left_node:
 *         def __get__(self):             # <<<<<<<<<<<<<< 
 *             return self.cleft if self.cleft is not EmptyNode else None
 *     property right_node:
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_9left_node___get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_9left_node___get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  int __pyx_2;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":75
 *     property left_node:
 *         def __get__(self):
 *             return self.cleft if self.cleft is not EmptyNode else None             # <<<<<<<<<<<<<< 
 *     property right_node:
 *         def __get__(self):
 */
  __pyx_2 = (((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->cleft != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_2) {
    __pyx_1 = ((PyObject *)((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->cleft);
    Py_INCREF(__pyx_1);
    } else {
    __pyx_1 = Py_None;
    Py_INCREF(__pyx_1);
  }
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":77
 *             return self.cleft if self.cleft is not EmptyNode else None
 *     property right_node:
 *         def __get__(self):             # <<<<<<<<<<<<<< 
 *             return self.cright if self.cright is not EmptyNode else None
 *     property root_node:
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_10right_node___get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_10right_node___get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  int __pyx_2;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":78
 *     property right_node:
 *         def __get__(self):
 *             return self.cright if self.cright is not EmptyNode else None             # <<<<<<<<<<<<<< 
 *     property root_node:
 *         def __get__(self):
 */
  __pyx_2 = (((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->cright != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_2) {
    __pyx_1 = ((PyObject *)((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->cright);
    Py_INCREF(__pyx_1);
    } else {
    __pyx_1 = Py_None;
    Py_INCREF(__pyx_1);
  }
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":80
 *             return self.cright if self.cright is not EmptyNode else None
 *     property root_node:
 *         def __get__(self):             # <<<<<<<<<<<<<< 
 *             return self.croot if self.croot is not EmptyNode else None
 *     
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_9root_node___get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_9root_node___get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  int __pyx_2;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":81
 *     property root_node:
 *         def __get__(self):
 *             return self.croot if self.croot is not EmptyNode else None             # <<<<<<<<<<<<<< 
 *     
 *     def __repr__(self):
 */
  __pyx_2 = (((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->croot != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_2) {
    __pyx_1 = ((PyObject *)((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->croot);
    Py_INCREF(__pyx_1);
    } else {
    __pyx_1 = Py_None;
    Py_INCREF(__pyx_1);
  }
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":83
 *             return self.croot if self.croot is not EmptyNode else None
 *     
 *     def __repr__(self):             # <<<<<<<<<<<<<< 
 *         return "IntervalNode(%i, %i)" % (self.start, self.end)
 * 
 */

static PyObject *__pyx_k_2p;

static char __pyx_k_2[] = "IntervalNode(%i, %i)";

static PyObject *__pyx_pf_13cintervaltree_12IntervalNode___repr__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_13cintervaltree_12IntervalNode___repr__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":84
 *     
 *     def __repr__(self):
 *         return "IntervalNode(%i, %i)" % (self.start, self.end)             # <<<<<<<<<<<<<< 
 * 
 *     def __cinit__(IntervalNode self, int start, int end, object interval):
 */
  __pyx_1 = PyInt_FromLong(((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->start); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = PyInt_FromLong(((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->end); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_3 = PyTuple_New(2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1;}
  PyTuple_SET_ITEM(__pyx_3, 0, __pyx_1);
  PyTuple_SET_ITEM(__pyx_3, 1, __pyx_2);
  __pyx_1 = 0;
  __pyx_2 = 0;
  __pyx_1 = PyNumber_Remainder(__pyx_k_2p, ((PyObject *)__pyx_3)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(((PyObject *)__pyx_3)); __pyx_3 = 0;
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("cintervaltree.IntervalNode.__repr__");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":86
 *         return "IntervalNode(%i, %i)" % (self.start, self.end)
 * 
 *     def __cinit__(IntervalNode self, int start, int end, object interval):             # <<<<<<<<<<<<<< 
 *         # Python lacks the binomial distribution, so we convert a
 *         # uniform into a binomial because it naturally scales with
 */

static int __pyx_pf_13cintervaltree_12IntervalNode___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pf_13cintervaltree_12IntervalNode___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_start;
  int __pyx_v_end;
  PyObject *__pyx_v_interval = 0;
  int __pyx_r;
  static char *__pyx_argnames[] = {"start","end","interval",0};
  if (likely(!__pyx_kwds) && likely(PyTuple_GET_SIZE(__pyx_args) == 3)) {
    __pyx_v_start = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_start == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L2;}
    __pyx_v_end = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_end == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L2;}
    __pyx_v_interval = PyTuple_GET_ITEM(__pyx_args, 2);
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "iiO", __pyx_argnames, &__pyx_v_start, &__pyx_v_end, &__pyx_v_interval))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalNode.__cinit__");
  return -1;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":91
 *         # tree size.  Also, python's uniform is perfect since the
 *         # upper limit is not inclusive, which gives us undefined here.
 *         self.priority   = ceil(nlog * log(-1.0/(1.0 * rand()/RAND_MAX - 1)))             # <<<<<<<<<<<<<< 
 *         self.start      = start
 *         self.end       = end
 */
  ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->priority = ceil((__pyx_v_13cintervaltree_nlog * log(((-1.0) / (((1.0 * rand()) / RAND_MAX) - 1)))));

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":92
 *         # upper limit is not inclusive, which gives us undefined here.
 *         self.priority   = ceil(nlog * log(-1.0/(1.0 * rand()/RAND_MAX - 1)))
 *         self.start      = start             # <<<<<<<<<<<<<< 
 *         self.end       = end
 *         self.interval   = interval
 */
  ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->start = __pyx_v_start;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":93
 *         self.priority   = ceil(nlog * log(-1.0/(1.0 * rand()/RAND_MAX - 1)))
 *         self.start      = start
 *         self.end       = end             # <<<<<<<<<<<<<< 
 *         self.interval   = interval
 *         self.maxend    = end
 */
  ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->end = __pyx_v_end;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":94
 *         self.start      = start
 *         self.end       = end
 *         self.interval   = interval             # <<<<<<<<<<<<<< 
 *         self.maxend    = end
 *         self.minstart   = start
 */
  Py_INCREF(__pyx_v_interval);
  Py_DECREF(((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->interval);
  ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->interval = __pyx_v_interval;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":95
 *         self.end       = end
 *         self.interval   = interval
 *         self.maxend    = end             # <<<<<<<<<<<<<< 
 *         self.minstart   = start
 *         self.minend    = end
 */
  ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->maxend = __pyx_v_end;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":96
 *         self.interval   = interval
 *         self.maxend    = end
 *         self.minstart   = start             # <<<<<<<<<<<<<< 
 *         self.minend    = end
 *         self.cleft       = EmptyNode
 */
  ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->minstart = __pyx_v_start;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":97
 *         self.maxend    = end
 *         self.minstart   = start
 *         self.minend    = end             # <<<<<<<<<<<<<< 
 *         self.cleft       = EmptyNode
 *         self.cright      = EmptyNode
 */
  ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->minend = __pyx_v_end;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":98
 *         self.minstart   = start
 *         self.minend    = end
 *         self.cleft       = EmptyNode             # <<<<<<<<<<<<<< 
 *         self.cright      = EmptyNode
 *         self.croot       = EmptyNode
 */
  Py_INCREF(((PyObject *)__pyx_v_13cintervaltree_EmptyNode));
  Py_DECREF(((PyObject *)((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->cleft));
  ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->cleft = __pyx_v_13cintervaltree_EmptyNode;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":99
 *         self.minend    = end
 *         self.cleft       = EmptyNode
 *         self.cright      = EmptyNode             # <<<<<<<<<<<<<< 
 *         self.croot       = EmptyNode
 *         
 */
  Py_INCREF(((PyObject *)__pyx_v_13cintervaltree_EmptyNode));
  Py_DECREF(((PyObject *)((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->cright));
  ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->cright = __pyx_v_13cintervaltree_EmptyNode;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":100
 *         self.cleft       = EmptyNode
 *         self.cright      = EmptyNode
 *         self.croot       = EmptyNode             # <<<<<<<<<<<<<< 
 *         
 *     cpdef IntervalNode insert(IntervalNode self, int start, int end, object interval):
 */
  Py_INCREF(((PyObject *)__pyx_v_13cintervaltree_EmptyNode));
  Py_DECREF(((PyObject *)((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->croot));
  ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->croot = __pyx_v_13cintervaltree_EmptyNode;

  __pyx_r = 0;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":102
 *         self.croot       = EmptyNode
 *         
 *     cpdef IntervalNode insert(IntervalNode self, int start, int end, object interval):             # <<<<<<<<<<<<<< 
 *         """
 *         Insert a new IntervalNode into the tree of which this node is
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_insert(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static  struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_f_13cintervaltree_12IntervalNode_insert(struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_self, int __pyx_v_start, int __pyx_v_end, PyObject *__pyx_v_interval) {
  struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_croot = 0;
  int __pyx_v_decision_endpoint;
  struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  int __pyx_5;
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) __pyx_skip_dispatch = 0;
  /* Check if overriden in Python */
  else if (unlikely(((PyObject *)__pyx_v_self)->ob_type->tp_dictoffset != 0)) {
    __pyx_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_insert); if (unlikely(!((PyObject *)__pyx_v_self))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1;}
    if (!(strcmp(__pyx_1->ob_type->tp_name, "builtin_function_or_method") == 0) || (PyCFunction_GET_FUNCTION(__pyx_1) != (void *)&__pyx_pf_13cintervaltree_12IntervalNode_insert)) {
      __pyx_2 = PyInt_FromLong(__pyx_v_start); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_3 = PyInt_FromLong(__pyx_v_end); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_4 = PyTuple_New(3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1;}
      PyTuple_SET_ITEM(__pyx_4, 0, __pyx_2);
      PyTuple_SET_ITEM(__pyx_4, 1, __pyx_3);
      Py_INCREF(__pyx_v_interval);
      PyTuple_SET_ITEM(__pyx_4, 2, __pyx_v_interval);
      __pyx_2 = 0;
      __pyx_3 = 0;
      __pyx_2 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_4), NULL); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(__pyx_1); __pyx_1 = 0;
      Py_DECREF(((PyObject *)__pyx_4)); __pyx_4 = 0;
      if (!(__Pyx_TypeTest(__pyx_2, __pyx_ptype_13cintervaltree_IntervalNode))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_r = ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_2);
      __pyx_2 = 0;
      goto __pyx_L0;
    }
  }

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":108
 *         may or may not be this node!)
 *         """
 *         cdef IntervalNode croot = self             # <<<<<<<<<<<<<< 
 *         # If starts are the same, decide which to add interval to based on
 *         # end, thus maintaining sortedness relative to start/end
 */
  Py_INCREF(((PyObject *)__pyx_v_self));
  __pyx_v_croot = __pyx_v_self;


  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":111
 *         # If starts are the same, decide which to add interval to based on
 *         # end, thus maintaining sortedness relative to start/end
 *         cdef int decision_endpoint = start             # <<<<<<<<<<<<<< 
 *         if start == self.start:
 *             decision_endpoint = end
 */
  __pyx_v_decision_endpoint = __pyx_v_start;


  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":112
 *         # end, thus maintaining sortedness relative to start/end
 *         cdef int decision_endpoint = start
 *         if start == self.start:             # <<<<<<<<<<<<<< 
 *             decision_endpoint = end
 *         
 */
  __pyx_5 = (__pyx_v_start == __pyx_v_self->start);
  if (__pyx_5) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":113
 *         cdef int decision_endpoint = start
 *         if start == self.start:
 *             decision_endpoint = end             # <<<<<<<<<<<<<< 
 *         
 *         if decision_endpoint > self.start:
 */
    __pyx_v_decision_endpoint = __pyx_v_end;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":115
 *             decision_endpoint = end
 *         
 *         if decision_endpoint > self.start:             # <<<<<<<<<<<<<< 
 *             # insert to cright tree
 *             if self.cright is not EmptyNode:
 */
  __pyx_5 = (__pyx_v_decision_endpoint > __pyx_v_self->start);
  if (__pyx_5) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":117
 *         if decision_endpoint > self.start:
 *             # insert to cright tree
 *             if self.cright is not EmptyNode:             # <<<<<<<<<<<<<< 
 *                 self.cright = self.cright.insert( start, end, interval )
 *             else:
 */
    __pyx_5 = (__pyx_v_self->cright != __pyx_v_13cintervaltree_EmptyNode);
    if (__pyx_5) {

      /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":118
 *             # insert to cright tree
 *             if self.cright is not EmptyNode:
 *                 self.cright = self.cright.insert( start, end, interval )             # <<<<<<<<<<<<<< 
 *             else:
 *                 self.cright = IntervalNode( start, end, interval )
 */
      __pyx_3 = ((PyObject *)((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->cright->__pyx_vtab)->insert(__pyx_v_self->cright, __pyx_v_start, __pyx_v_end, __pyx_v_interval)); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(((PyObject *)__pyx_v_self->cright));
      __pyx_v_self->cright = ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_3);
      __pyx_3 = 0;
      goto __pyx_L4;
    }
    /*else*/ {

      /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":120
 *                 self.cright = self.cright.insert( start, end, interval )
 *             else:
 *                 self.cright = IntervalNode( start, end, interval )             # <<<<<<<<<<<<<< 
 *             # rebalance tree
 *             if self.priority < self.cright.priority:
 */
      __pyx_1 = PyInt_FromLong(__pyx_v_start); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_4 = PyInt_FromLong(__pyx_v_end); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_2 = PyTuple_New(3); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1;}
      PyTuple_SET_ITEM(__pyx_2, 0, __pyx_1);
      PyTuple_SET_ITEM(__pyx_2, 1, __pyx_4);
      Py_INCREF(__pyx_v_interval);
      PyTuple_SET_ITEM(__pyx_2, 2, __pyx_v_interval);
      __pyx_1 = 0;
      __pyx_4 = 0;
      __pyx_3 = PyObject_Call(((PyObject*)__pyx_ptype_13cintervaltree_IntervalNode), ((PyObject *)__pyx_2), NULL); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(((PyObject *)__pyx_2)); __pyx_2 = 0;
      if (!(__Pyx_TypeTest(__pyx_3, __pyx_ptype_13cintervaltree_IntervalNode))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(((PyObject *)__pyx_v_self->cright));
      __pyx_v_self->cright = ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_3);
      __pyx_3 = 0;
    }
    __pyx_L4:;

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":122
 *                 self.cright = IntervalNode( start, end, interval )
 *             # rebalance tree
 *             if self.priority < self.cright.priority:             # <<<<<<<<<<<<<< 
 *                 croot = self.rotate_left()
 *         else:
 */
    __pyx_5 = (__pyx_v_self->priority < __pyx_v_self->cright->priority);
    if (__pyx_5) {

      /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":123
 *             # rebalance tree
 *             if self.priority < self.cright.priority:
 *                 croot = self.rotate_left()             # <<<<<<<<<<<<<< 
 *         else:
 *             # insert to cleft tree
 */
      __pyx_1 = ((PyObject *)((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->__pyx_vtab)->rotate_left(__pyx_v_self)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(((PyObject *)__pyx_v_croot));
      __pyx_v_croot = ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_1);
      __pyx_1 = 0;
      goto __pyx_L5;
    }
    __pyx_L5:;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":126
 *         else:
 *             # insert to cleft tree
 *             if self.cleft is not EmptyNode:             # <<<<<<<<<<<<<< 
 *                 self.cleft = self.cleft.insert( start, end, interval)
 *             else:
 */
    __pyx_5 = (__pyx_v_self->cleft != __pyx_v_13cintervaltree_EmptyNode);
    if (__pyx_5) {

      /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":127
 *             # insert to cleft tree
 *             if self.cleft is not EmptyNode:
 *                 self.cleft = self.cleft.insert( start, end, interval)             # <<<<<<<<<<<<<< 
 *             else:
 *                 self.cleft = IntervalNode( start, end, interval)
 */
      __pyx_4 = ((PyObject *)((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->cleft->__pyx_vtab)->insert(__pyx_v_self->cleft, __pyx_v_start, __pyx_v_end, __pyx_v_interval)); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(((PyObject *)__pyx_v_self->cleft));
      __pyx_v_self->cleft = ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_4);
      __pyx_4 = 0;
      goto __pyx_L6;
    }
    /*else*/ {

      /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":129
 *                 self.cleft = self.cleft.insert( start, end, interval)
 *             else:
 *                 self.cleft = IntervalNode( start, end, interval)             # <<<<<<<<<<<<<< 
 *             # rebalance tree
 *             if self.priority < self.cleft.priority:
 */
      __pyx_2 = PyInt_FromLong(__pyx_v_start); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_3 = PyInt_FromLong(__pyx_v_end); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_1 = PyTuple_New(3); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1;}
      PyTuple_SET_ITEM(__pyx_1, 0, __pyx_2);
      PyTuple_SET_ITEM(__pyx_1, 1, __pyx_3);
      Py_INCREF(__pyx_v_interval);
      PyTuple_SET_ITEM(__pyx_1, 2, __pyx_v_interval);
      __pyx_2 = 0;
      __pyx_3 = 0;
      __pyx_4 = PyObject_Call(((PyObject*)__pyx_ptype_13cintervaltree_IntervalNode), ((PyObject *)__pyx_1), NULL); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
      if (!(__Pyx_TypeTest(__pyx_4, __pyx_ptype_13cintervaltree_IntervalNode))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(((PyObject *)__pyx_v_self->cleft));
      __pyx_v_self->cleft = ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_4);
      __pyx_4 = 0;
    }
    __pyx_L6:;

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":131
 *                 self.cleft = IntervalNode( start, end, interval)
 *             # rebalance tree
 *             if self.priority < self.cleft.priority:             # <<<<<<<<<<<<<< 
 *                 croot = self.rotate_right()
 *     
 */
    __pyx_5 = (__pyx_v_self->priority < __pyx_v_self->cleft->priority);
    if (__pyx_5) {

      /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":132
 *             # rebalance tree
 *             if self.priority < self.cleft.priority:
 *                 croot = self.rotate_right()             # <<<<<<<<<<<<<< 
 *     
 *         croot.set_ends()
 */
      __pyx_2 = ((PyObject *)((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->__pyx_vtab)->rotate_right(__pyx_v_self)); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 132; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(((PyObject *)__pyx_v_croot));
      __pyx_v_croot = ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_2);
      __pyx_2 = 0;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":134
 *                 croot = self.rotate_right()
 *     
 *         croot.set_ends()             # <<<<<<<<<<<<<< 
 *         self.cleft.croot  = croot
 *         self.cright.croot = croot
 */
  ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_croot->__pyx_vtab)->set_ends(__pyx_v_croot);

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":135
 *     
 *         croot.set_ends()
 *         self.cleft.croot  = croot             # <<<<<<<<<<<<<< 
 *         self.cright.croot = croot
 *         return croot
 */
  Py_INCREF(((PyObject *)__pyx_v_croot));
  Py_DECREF(((PyObject *)__pyx_v_self->cleft->croot));
  __pyx_v_self->cleft->croot = __pyx_v_croot;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":136
 *         croot.set_ends()
 *         self.cleft.croot  = croot
 *         self.cright.croot = croot             # <<<<<<<<<<<<<< 
 *         return croot
 * 
 */
  Py_INCREF(((PyObject *)__pyx_v_croot));
  Py_DECREF(((PyObject *)__pyx_v_self->cright->croot));
  __pyx_v_self->cright->croot = __pyx_v_croot;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":137
 *         self.cleft.croot  = croot
 *         self.cright.croot = croot
 *         return croot             # <<<<<<<<<<<<<< 
 * 
 *     cdef IntervalNode rotate_right(IntervalNode self):
 */
  Py_INCREF(((PyObject *)__pyx_v_croot));
  __pyx_r = __pyx_v_croot;
  goto __pyx_L0;

  __pyx_r = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("cintervaltree.IntervalNode.insert");
  __pyx_r = 0;
  __pyx_L0:;
  Py_XDECREF(__pyx_v_croot);
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":102
 *         self.croot       = EmptyNode
 *         
 *     cpdef IntervalNode insert(IntervalNode self, int start, int end, object interval):             # <<<<<<<<<<<<<< 
 *         """
 *         Insert a new IntervalNode into the tree of which this node is
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_insert(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalNode_insert[] = "\n        Insert a new IntervalNode into the tree of which this node is\n        currently the root. The return value is the new root of the tree (which\n        may or may not be this node!)\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_insert(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_start;
  int __pyx_v_end;
  PyObject *__pyx_v_interval = 0;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  static char *__pyx_argnames[] = {"start","end","interval",0};
  if (likely(!__pyx_kwds) && likely(PyTuple_GET_SIZE(__pyx_args) == 3)) {
    __pyx_v_start = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_start == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L2;}
    __pyx_v_end = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_end == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L2;}
    __pyx_v_interval = PyTuple_GET_ITEM(__pyx_args, 2);
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "iiO", __pyx_argnames, &__pyx_v_start, &__pyx_v_end, &__pyx_v_interval))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalNode.insert");
  return NULL;
  __pyx_L3:;
  __pyx_1 = ((PyObject *)(__pyx_skip_dispatch = 1, ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->__pyx_vtab)->insert(((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self), __pyx_v_start, __pyx_v_end, __pyx_v_interval))); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  __Pyx_AddTraceback("cintervaltree.IntervalNode.insert");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":139
 *         return croot
 * 
 *     cdef IntervalNode rotate_right(IntervalNode self):             # <<<<<<<<<<<<<< 
 *         cdef IntervalNode croot = self.cleft
 *         self.cleft  = self.cleft.cright
 */

static  struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_f_13cintervaltree_12IntervalNode_rotate_right(struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_self) {
  struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_croot = 0;
  struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_r;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":140
 * 
 *     cdef IntervalNode rotate_right(IntervalNode self):
 *         cdef IntervalNode croot = self.cleft             # <<<<<<<<<<<<<< 
 *         self.cleft  = self.cleft.cright
 *         croot.cright = self
 */
  Py_INCREF(((PyObject *)__pyx_v_self->cleft));
  __pyx_v_croot = __pyx_v_self->cleft;


  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":141
 *     cdef IntervalNode rotate_right(IntervalNode self):
 *         cdef IntervalNode croot = self.cleft
 *         self.cleft  = self.cleft.cright             # <<<<<<<<<<<<<< 
 *         croot.cright = self
 *         self.set_ends()
 */
  Py_INCREF(((PyObject *)__pyx_v_self->cleft->cright));
  Py_DECREF(((PyObject *)__pyx_v_self->cleft));
  __pyx_v_self->cleft = __pyx_v_self->cleft->cright;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":142
 *         cdef IntervalNode croot = self.cleft
 *         self.cleft  = self.cleft.cright
 *         croot.cright = self             # <<<<<<<<<<<<<< 
 *         self.set_ends()
 *         return croot
 */
  Py_INCREF(((PyObject *)__pyx_v_self));
  Py_DECREF(((PyObject *)__pyx_v_croot->cright));
  __pyx_v_croot->cright = __pyx_v_self;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":143
 *         self.cleft  = self.cleft.cright
 *         croot.cright = self
 *         self.set_ends()             # <<<<<<<<<<<<<< 
 *         return croot
 * 
 */
  ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->__pyx_vtab)->set_ends(__pyx_v_self);

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":144
 *         croot.cright = self
 *         self.set_ends()
 *         return croot             # <<<<<<<<<<<<<< 
 * 
 *     cdef IntervalNode rotate_left(IntervalNode self):
 */
  Py_INCREF(((PyObject *)__pyx_v_croot));
  __pyx_r = __pyx_v_croot;
  goto __pyx_L0;

  __pyx_r = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  __pyx_L0:;
  Py_XDECREF(__pyx_v_croot);
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":146
 *         return croot
 * 
 *     cdef IntervalNode rotate_left(IntervalNode self):             # <<<<<<<<<<<<<< 
 *         cdef IntervalNode croot = self.cright
 *         self.cright = self.cright.cleft
 */

static  struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_f_13cintervaltree_12IntervalNode_rotate_left(struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_self) {
  struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_croot = 0;
  struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_r;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":147
 * 
 *     cdef IntervalNode rotate_left(IntervalNode self):
 *         cdef IntervalNode croot = self.cright             # <<<<<<<<<<<<<< 
 *         self.cright = self.cright.cleft
 *         croot.cleft  = self
 */
  Py_INCREF(((PyObject *)__pyx_v_self->cright));
  __pyx_v_croot = __pyx_v_self->cright;


  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":148
 *     cdef IntervalNode rotate_left(IntervalNode self):
 *         cdef IntervalNode croot = self.cright
 *         self.cright = self.cright.cleft             # <<<<<<<<<<<<<< 
 *         croot.cleft  = self
 *         self.set_ends()
 */
  Py_INCREF(((PyObject *)__pyx_v_self->cright->cleft));
  Py_DECREF(((PyObject *)__pyx_v_self->cright));
  __pyx_v_self->cright = __pyx_v_self->cright->cleft;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":149
 *         cdef IntervalNode croot = self.cright
 *         self.cright = self.cright.cleft
 *         croot.cleft  = self             # <<<<<<<<<<<<<< 
 *         self.set_ends()
 *         return croot
 */
  Py_INCREF(((PyObject *)__pyx_v_self));
  Py_DECREF(((PyObject *)__pyx_v_croot->cleft));
  __pyx_v_croot->cleft = __pyx_v_self;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":150
 *         self.cright = self.cright.cleft
 *         croot.cleft  = self
 *         self.set_ends()             # <<<<<<<<<<<<<< 
 *         return croot
 * 
 */
  ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->__pyx_vtab)->set_ends(__pyx_v_self);

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":151
 *         croot.cleft  = self
 *         self.set_ends()
 *         return croot             # <<<<<<<<<<<<<< 
 * 
 *     cdef inline void set_ends(IntervalNode self):
 */
  Py_INCREF(((PyObject *)__pyx_v_croot));
  __pyx_r = __pyx_v_croot;
  goto __pyx_L0;

  __pyx_r = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  __pyx_L0:;
  Py_XDECREF(__pyx_v_croot);
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":153
 *         return croot
 * 
 *     cdef inline void set_ends(IntervalNode self):             # <<<<<<<<<<<<<< 
 *         if self.cright is not EmptyNode and self.cleft is not EmptyNode: 
 *             self.maxend = imax3(self.end, self.cright.maxend, self.cleft.maxend)
 */

static INLINE void __pyx_f_13cintervaltree_12IntervalNode_set_ends(struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_self) {
  int __pyx_1;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":154
 * 
 *     cdef inline void set_ends(IntervalNode self):
 *         if self.cright is not EmptyNode and self.cleft is not EmptyNode:             # <<<<<<<<<<<<<< 
 *             self.maxend = imax3(self.end, self.cright.maxend, self.cleft.maxend)
 *             self.minend = imin3(self.end, self.cright.minend, self.cleft.minend)
 */
  __pyx_1 = (__pyx_v_self->cright != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_1) {
    __pyx_1 = (__pyx_v_self->cleft != __pyx_v_13cintervaltree_EmptyNode);
  }
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":155
 *     cdef inline void set_ends(IntervalNode self):
 *         if self.cright is not EmptyNode and self.cleft is not EmptyNode: 
 *             self.maxend = imax3(self.end, self.cright.maxend, self.cleft.maxend)             # <<<<<<<<<<<<<< 
 *             self.minend = imin3(self.end, self.cright.minend, self.cleft.minend)
 *             self.minstart = imin3(self.start, self.cright.minstart, self.cleft.minstart)
 */
    __pyx_v_self->maxend = __pyx_f_13cintervaltree_imax3(__pyx_v_self->end, __pyx_v_self->cright->maxend, __pyx_v_self->cleft->maxend);

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":156
 *         if self.cright is not EmptyNode and self.cleft is not EmptyNode: 
 *             self.maxend = imax3(self.end, self.cright.maxend, self.cleft.maxend)
 *             self.minend = imin3(self.end, self.cright.minend, self.cleft.minend)             # <<<<<<<<<<<<<< 
 *             self.minstart = imin3(self.start, self.cright.minstart, self.cleft.minstart)
 *         elif self.cright is not EmptyNode:
 */
    __pyx_v_self->minend = __pyx_f_13cintervaltree_imin3(__pyx_v_self->end, __pyx_v_self->cright->minend, __pyx_v_self->cleft->minend);

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":157
 *             self.maxend = imax3(self.end, self.cright.maxend, self.cleft.maxend)
 *             self.minend = imin3(self.end, self.cright.minend, self.cleft.minend)
 *             self.minstart = imin3(self.start, self.cright.minstart, self.cleft.minstart)             # <<<<<<<<<<<<<< 
 *         elif self.cright is not EmptyNode:
 *             self.maxend = imax2(self.end, self.cright.maxend)
 */
    __pyx_v_self->minstart = __pyx_f_13cintervaltree_imin3(__pyx_v_self->start, __pyx_v_self->cright->minstart, __pyx_v_self->cleft->minstart);
    goto __pyx_L2;
  }

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":158
 *             self.minend = imin3(self.end, self.cright.minend, self.cleft.minend)
 *             self.minstart = imin3(self.start, self.cright.minstart, self.cleft.minstart)
 *         elif self.cright is not EmptyNode:             # <<<<<<<<<<<<<< 
 *             self.maxend = imax2(self.end, self.cright.maxend)
 *             self.minend = imin2(self.end, self.cright.minend)
 */
  __pyx_1 = (__pyx_v_self->cright != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":159
 *             self.minstart = imin3(self.start, self.cright.minstart, self.cleft.minstart)
 *         elif self.cright is not EmptyNode:
 *             self.maxend = imax2(self.end, self.cright.maxend)             # <<<<<<<<<<<<<< 
 *             self.minend = imin2(self.end, self.cright.minend)
 *             self.minstart = imin2(self.start, self.cright.minstart)
 */
    __pyx_v_self->maxend = __pyx_f_13cintervaltree_imax2(__pyx_v_self->end, __pyx_v_self->cright->maxend);

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":160
 *         elif self.cright is not EmptyNode:
 *             self.maxend = imax2(self.end, self.cright.maxend)
 *             self.minend = imin2(self.end, self.cright.minend)             # <<<<<<<<<<<<<< 
 *             self.minstart = imin2(self.start, self.cright.minstart)
 *         elif self.cleft is not EmptyNode:
 */
    __pyx_v_self->minend = __pyx_f_13cintervaltree_imin2(__pyx_v_self->end, __pyx_v_self->cright->minend);

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":161
 *             self.maxend = imax2(self.end, self.cright.maxend)
 *             self.minend = imin2(self.end, self.cright.minend)
 *             self.minstart = imin2(self.start, self.cright.minstart)             # <<<<<<<<<<<<<< 
 *         elif self.cleft is not EmptyNode:
 *             self.maxend = imax2(self.end, self.cleft.maxend)
 */
    __pyx_v_self->minstart = __pyx_f_13cintervaltree_imin2(__pyx_v_self->start, __pyx_v_self->cright->minstart);
    goto __pyx_L2;
  }

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":162
 *             self.minend = imin2(self.end, self.cright.minend)
 *             self.minstart = imin2(self.start, self.cright.minstart)
 *         elif self.cleft is not EmptyNode:             # <<<<<<<<<<<<<< 
 *             self.maxend = imax2(self.end, self.cleft.maxend)
 *             self.minend = imin2(self.end, self.cleft.minend)
 */
  __pyx_1 = (__pyx_v_self->cleft != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":163
 *             self.minstart = imin2(self.start, self.cright.minstart)
 *         elif self.cleft is not EmptyNode:
 *             self.maxend = imax2(self.end, self.cleft.maxend)             # <<<<<<<<<<<<<< 
 *             self.minend = imin2(self.end, self.cleft.minend)
 *             self.minstart = imin2(self.start, self.cleft.minstart)
 */
    __pyx_v_self->maxend = __pyx_f_13cintervaltree_imax2(__pyx_v_self->end, __pyx_v_self->cleft->maxend);

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":164
 *         elif self.cleft is not EmptyNode:
 *             self.maxend = imax2(self.end, self.cleft.maxend)
 *             self.minend = imin2(self.end, self.cleft.minend)             # <<<<<<<<<<<<<< 
 *             self.minstart = imin2(self.start, self.cleft.minstart)
 *         
 */
    __pyx_v_self->minend = __pyx_f_13cintervaltree_imin2(__pyx_v_self->end, __pyx_v_self->cleft->minend);

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":165
 *             self.maxend = imax2(self.end, self.cleft.maxend)
 *             self.minend = imin2(self.end, self.cleft.minend)
 *             self.minstart = imin2(self.start, self.cleft.minstart)             # <<<<<<<<<<<<<< 
 *         
 * 
 */
    __pyx_v_self->minstart = __pyx_f_13cintervaltree_imin2(__pyx_v_self->start, __pyx_v_self->cleft->minstart);
    goto __pyx_L2;
  }
  __pyx_L2:;

}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":168
 *         
 * 
 *     def intersect( self, int start, int end, sort=True ):             # <<<<<<<<<<<<<< 
 *         """
 *         given a start and a end, return a list of features
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_intersect(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalNode_intersect[] = "\n        given a start and a end, return a list of features\n        falling within that range\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_intersect(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_start;
  int __pyx_v_end;
  PyObject *__pyx_v_sort = 0;
  PyObject *__pyx_v_results = 0;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  static char *__pyx_argnames[] = {"start","end","sort",0};
  __pyx_v_sort = Py_True;
  if (likely(!__pyx_kwds) && likely(2 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 3)) {
    __pyx_v_start = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_start == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L2;}
    __pyx_v_end = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_end == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L2;}
    if (PyTuple_GET_SIZE(__pyx_args) > 2) {
      __pyx_v_sort = PyTuple_GET_ITEM(__pyx_args, 2);
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "ii|O", __pyx_argnames, &__pyx_v_start, &__pyx_v_end, &__pyx_v_sort))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalNode.intersect");
  return NULL;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":173
 *         falling within that range
 *         """
 *         cdef list results = []             # <<<<<<<<<<<<<< 
 *         self._intersect( start, end, results )
 *         return results
 */
  __pyx_1 = PyList_New(0); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_v_results = __pyx_1;
  __pyx_1 = 0;


  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":174
 *         """
 *         cdef list results = []
 *         self._intersect( start, end, results )             # <<<<<<<<<<<<<< 
 *         return results
 * 
 */
  ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->__pyx_vtab)->_intersect(((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self), __pyx_v_start, __pyx_v_end, __pyx_v_results);

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":175
 *         cdef list results = []
 *         self._intersect( start, end, results )
 *         return results             # <<<<<<<<<<<<<< 
 * 
 *     find = intersect
 */
  Py_INCREF(((PyObject *)__pyx_v_results));
  __pyx_r = ((PyObject *)__pyx_v_results);
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  __Pyx_AddTraceback("cintervaltree.IntervalNode.intersect");
  __pyx_r = NULL;
  __pyx_L0:;
  Py_XDECREF(__pyx_v_results);
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":179
 *     find = intersect
 *         
 *     cdef void _intersect( IntervalNode self, int start, int end, list results ):             # <<<<<<<<<<<<<< 
 *         # Left subtree
 *         if self.cleft is not EmptyNode and self.cleft.maxend > start:
 */

static  void __pyx_f_13cintervaltree_12IntervalNode__intersect(struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_self, int __pyx_v_start, int __pyx_v_end, PyObject *__pyx_v_results) {
  int __pyx_1;
  int __pyx_2;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":181
 *     cdef void _intersect( IntervalNode self, int start, int end, list results ):
 *         # Left subtree
 *         if self.cleft is not EmptyNode and self.cleft.maxend > start:             # <<<<<<<<<<<<<< 
 *             self.cleft._intersect( start, end, results )
 *         # This interval
 */
  __pyx_1 = (__pyx_v_self->cleft != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_1) {
    __pyx_1 = (__pyx_v_self->cleft->maxend > __pyx_v_start);
  }
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":182
 *         # Left subtree
 *         if self.cleft is not EmptyNode and self.cleft.maxend > start:
 *             self.cleft._intersect( start, end, results )             # <<<<<<<<<<<<<< 
 *         # This interval
 *         if ( self.end > start ) and ( self.start < end ):
 */
    ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->cleft->__pyx_vtab)->_intersect(__pyx_v_self->cleft, __pyx_v_start, __pyx_v_end, __pyx_v_results);
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":184
 *             self.cleft._intersect( start, end, results )
 *         # This interval
 *         if ( self.end > start ) and ( self.start < end ):             # <<<<<<<<<<<<<< 
 *             results.append( self.interval )
 *         # Right subtree
 */
  __pyx_1 = (__pyx_v_self->end > __pyx_v_start);
  if (__pyx_1) {
    __pyx_1 = (__pyx_v_self->start < __pyx_v_end);
  }
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":185
 *         # This interval
 *         if ( self.end > start ) and ( self.start < end ):
 *             results.append( self.interval )             # <<<<<<<<<<<<<< 
 *         # Right subtree
 *         if self.cright is not EmptyNode and self.start < end:
 */
    __pyx_2 = PyList_Append(((PyObject *)__pyx_v_results), __pyx_v_self->interval); if (unlikely(__pyx_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1;}
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":187
 *             results.append( self.interval )
 *         # Right subtree
 *         if self.cright is not EmptyNode and self.start < end:             # <<<<<<<<<<<<<< 
 *             self.cright._intersect( start, end, results )
 *     
 */
  __pyx_1 = (__pyx_v_self->cright != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_1) {
    __pyx_1 = (__pyx_v_self->start < __pyx_v_end);
  }
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":188
 *         # Right subtree
 *         if self.cright is not EmptyNode and self.start < end:
 *             self.cright._intersect( start, end, results )             # <<<<<<<<<<<<<< 
 *     
 * 
 */
    ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->cright->__pyx_vtab)->_intersect(__pyx_v_self->cright, __pyx_v_start, __pyx_v_end, __pyx_v_results);
    goto __pyx_L4;
  }
  __pyx_L4:;

  goto __pyx_L0;
  __pyx_L1:;
  __Pyx_WriteUnraisable("cintervaltree.IntervalNode._intersect");
  __pyx_L0:;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":191
 *     
 * 
 *     cdef void _seek_left(IntervalNode self, int position, list results, int n, int max_dist):             # <<<<<<<<<<<<<< 
 *         # we know we can bail in these 2 cases.
 *         if self.maxend + max_dist < position:
 */

static  void __pyx_f_13cintervaltree_12IntervalNode__seek_left(struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_self, int __pyx_v_position, PyObject *__pyx_v_results, int __pyx_v_n, int __pyx_v_max_dist) {
  int __pyx_1;
  int __pyx_2;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":193
 *     cdef void _seek_left(IntervalNode self, int position, list results, int n, int max_dist):
 *         # we know we can bail in these 2 cases.
 *         if self.maxend + max_dist < position:             # <<<<<<<<<<<<<< 
 *             return
 *         if self.minstart > position:
 */
  __pyx_1 = ((__pyx_v_self->maxend + __pyx_v_max_dist) < __pyx_v_position);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":194
 *         # we know we can bail in these 2 cases.
 *         if self.maxend + max_dist < position:
 *             return             # <<<<<<<<<<<<<< 
 *         if self.minstart > position:
 *             return
 */
    goto __pyx_L0;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":195
 *         if self.maxend + max_dist < position:
 *             return
 *         if self.minstart > position:             # <<<<<<<<<<<<<< 
 *             return
 * 
 */
  __pyx_1 = (__pyx_v_self->minstart > __pyx_v_position);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":196
 *             return
 *         if self.minstart > position:
 *             return             # <<<<<<<<<<<<<< 
 * 
 *         # the ordering of these 3 blocks makes it so the results are
 */
    goto __pyx_L0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":200
 *         # the ordering of these 3 blocks makes it so the results are
 *         # ordered nearest to farest from the query position
 *         if self.cright is not EmptyNode:             # <<<<<<<<<<<<<< 
 *             self.cright._seek_left(position, results, n, max_dist)
 * 
 */
  __pyx_1 = (__pyx_v_self->cright != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":201
 *         # ordered nearest to farest from the query position
 *         if self.cright is not EmptyNode:
 *             self.cright._seek_left(position, results, n, max_dist)             # <<<<<<<<<<<<<< 
 * 
 *         if -1 < position - self.end < max_dist:
 */
    ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->cright->__pyx_vtab)->_seek_left(__pyx_v_self->cright, __pyx_v_position, __pyx_v_results, __pyx_v_n, __pyx_v_max_dist);
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":203
 *             self.cright._seek_left(position, results, n, max_dist)
 * 
 *         if -1 < position - self.end < max_dist:             # <<<<<<<<<<<<<< 
 *             results.append(self.interval)
 * 
 */
  __pyx_2 = (__pyx_v_position - __pyx_v_self->end);
  __pyx_1 = (-1 < __pyx_2);
  if (__pyx_1) {
    __pyx_1 = (__pyx_2 < __pyx_v_max_dist);
  }
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":204
 * 
 *         if -1 < position - self.end < max_dist:
 *             results.append(self.interval)             # <<<<<<<<<<<<<< 
 * 
 *         # TODO: can these conditionals be more stringent?
 */
    __pyx_2 = PyList_Append(((PyObject *)__pyx_v_results), __pyx_v_self->interval); if (unlikely(__pyx_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 204; __pyx_clineno = __LINE__; goto __pyx_L1;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":207
 * 
 *         # TODO: can these conditionals be more stringent?
 *         if self.cleft is not EmptyNode:             # <<<<<<<<<<<<<< 
 *                 self.cleft._seek_left(position, results, n, max_dist)
 * 
 */
  __pyx_1 = (__pyx_v_self->cleft != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":208
 *         # TODO: can these conditionals be more stringent?
 *         if self.cleft is not EmptyNode:
 *                 self.cleft._seek_left(position, results, n, max_dist)             # <<<<<<<<<<<<<< 
 * 
 * 
 */
    ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->cleft->__pyx_vtab)->_seek_left(__pyx_v_self->cleft, __pyx_v_position, __pyx_v_results, __pyx_v_n, __pyx_v_max_dist);
    goto __pyx_L6;
  }
  __pyx_L6:;

  goto __pyx_L0;
  __pyx_L1:;
  __Pyx_WriteUnraisable("cintervaltree.IntervalNode._seek_left");
  __pyx_L0:;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":212
 * 
 *     
 *     cdef void _seek_right(IntervalNode self, int position, list results, int n, int max_dist):             # <<<<<<<<<<<<<< 
 *         # we know we can bail in these 2 cases.
 *         if self.maxend < position: return
 */

static  void __pyx_f_13cintervaltree_12IntervalNode__seek_right(struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_self, int __pyx_v_position, PyObject *__pyx_v_results, int __pyx_v_n, int __pyx_v_max_dist) {
  int __pyx_1;
  int __pyx_2;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":214
 *     cdef void _seek_right(IntervalNode self, int position, list results, int n, int max_dist):
 *         # we know we can bail in these 2 cases.
 *         if self.maxend < position: return             # <<<<<<<<<<<<<< 
 *         if self.minstart - max_dist > position: return
 * 
 */
  __pyx_1 = (__pyx_v_self->maxend < __pyx_v_position);
  if (__pyx_1) {
    goto __pyx_L0;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":215
 *         # we know we can bail in these 2 cases.
 *         if self.maxend < position: return
 *         if self.minstart - max_dist > position: return             # <<<<<<<<<<<<<< 
 * 
 *         #print "SEEK_RIGHT:",self, self.cleft, self.maxend, self.minstart, position
 */
  __pyx_1 = ((__pyx_v_self->minstart - __pyx_v_max_dist) > __pyx_v_position);
  if (__pyx_1) {
    goto __pyx_L0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":221
 *         # the ordering of these 3 blocks makes it so the results are
 *         # ordered nearest to farest from the query position
 *         if self.cleft is not EmptyNode:             # <<<<<<<<<<<<<< 
 *                 self.cleft._seek_right(position, results, n, max_dist)
 * 
 */
  __pyx_1 = (__pyx_v_self->cleft != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":222
 *         # ordered nearest to farest from the query position
 *         if self.cleft is not EmptyNode: 
 *                 self.cleft._seek_right(position, results, n, max_dist)             # <<<<<<<<<<<<<< 
 * 
 *         if -1 < self.start - position < max_dist:
 */
    ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->cleft->__pyx_vtab)->_seek_right(__pyx_v_self->cleft, __pyx_v_position, __pyx_v_results, __pyx_v_n, __pyx_v_max_dist);
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":224
 *                 self.cleft._seek_right(position, results, n, max_dist)
 * 
 *         if -1 < self.start - position < max_dist:             # <<<<<<<<<<<<<< 
 *             results.append(self.interval)
 * 
 */
  __pyx_2 = (__pyx_v_self->start - __pyx_v_position);
  __pyx_1 = (-1 < __pyx_2);
  if (__pyx_1) {
    __pyx_1 = (__pyx_2 < __pyx_v_max_dist);
  }
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":225
 * 
 *         if -1 < self.start - position < max_dist:
 *             results.append(self.interval)             # <<<<<<<<<<<<<< 
 * 
 *         if self.cright is not EmptyNode:
 */
    __pyx_2 = PyList_Append(((PyObject *)__pyx_v_results), __pyx_v_self->interval); if (unlikely(__pyx_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":227
 *             results.append(self.interval)
 * 
 *         if self.cright is not EmptyNode:             # <<<<<<<<<<<<<< 
 *                 self.cright._seek_right(position, results, n, max_dist)
 * 
 */
  __pyx_1 = (__pyx_v_self->cright != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":228
 * 
 *         if self.cright is not EmptyNode:
 *                 self.cright._seek_right(position, results, n, max_dist)             # <<<<<<<<<<<<<< 
 * 
 *     
 */
    ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->cright->__pyx_vtab)->_seek_right(__pyx_v_self->cright, __pyx_v_position, __pyx_v_results, __pyx_v_n, __pyx_v_max_dist);
    goto __pyx_L6;
  }
  __pyx_L6:;

  goto __pyx_L0;
  __pyx_L1:;
  __Pyx_WriteUnraisable("cintervaltree.IntervalNode._seek_right");
  __pyx_L0:;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":245
 *     ##     return [left, right]
 *     
 *     cpdef left(self, position, int n=1, int max_dist=2500):             # <<<<<<<<<<<<<< 
 *         """
 *         find n features with a start > than `position`
 */

static PyObject *__pyx_n_sort;
static PyObject *__pyx_n_attrgetter;
static PyObject *__pyx_n_end;
static PyObject *__pyx_n_key;
static PyObject *__pyx_n_reverse;


static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_left(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static  PyObject *__pyx_f_13cintervaltree_12IntervalNode_left(struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_self, PyObject *__pyx_v_position, struct __pyx_opt_args_13cintervaltree_12IntervalNode_left *__pyx_optional_args) {
  int __pyx_v_n = 1;
  int __pyx_v_max_dist = 2500;
  PyObject *__pyx_v_results = 0;
  PyObject *__pyx_v_r;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  int __pyx_5;
  Py_ssize_t __pyx_6 = 0;
  int __pyx_7;
  PyObject *__pyx_8 = 0;
  if (__pyx_optional_args) {
    if (__pyx_optional_args->__pyx_n > 0) {
      __pyx_v_n = __pyx_optional_args->n;
      if (__pyx_optional_args->__pyx_n > 1) {
        __pyx_v_max_dist = __pyx_optional_args->max_dist;
      }
    }
  }
  __pyx_v_r = Py_None; Py_INCREF(Py_None);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) __pyx_skip_dispatch = 0;
  /* Check if overriden in Python */
  else if (unlikely(((PyObject *)__pyx_v_self)->ob_type->tp_dictoffset != 0)) {
    __pyx_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_left); if (unlikely(!((PyObject *)__pyx_v_self))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1;}
    if (!(strcmp(__pyx_1->ob_type->tp_name, "builtin_function_or_method") == 0) || (PyCFunction_GET_FUNCTION(__pyx_1) != (void *)&__pyx_pf_13cintervaltree_12IntervalNode_left)) {
      __pyx_2 = PyInt_FromLong(__pyx_v_n); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_3 = PyInt_FromLong(__pyx_v_max_dist); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_4 = PyTuple_New(3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_INCREF(__pyx_v_position);
      PyTuple_SET_ITEM(__pyx_4, 0, __pyx_v_position);
      PyTuple_SET_ITEM(__pyx_4, 1, __pyx_2);
      PyTuple_SET_ITEM(__pyx_4, 2, __pyx_3);
      __pyx_2 = 0;
      __pyx_3 = 0;
      __pyx_2 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_4), NULL); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(__pyx_1); __pyx_1 = 0;
      Py_DECREF(((PyObject *)__pyx_4)); __pyx_4 = 0;
      __pyx_r = __pyx_2;
      __pyx_2 = 0;
      goto __pyx_L0;
    }
  }

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":252
 *         max_dist: the maximum distance to look before giving up.
 *         """
 *         cdef list results = []             # <<<<<<<<<<<<<< 
 *         # use start - 1 becuase .left() assumes strictly left-of
 *         self._seek_left( position - 1, results, n, max_dist )
 */
  __pyx_3 = PyList_New(0); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_v_results = __pyx_3;
  __pyx_3 = 0;


  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":254
 *         cdef list results = []
 *         # use start - 1 becuase .left() assumes strictly left-of
 *         self._seek_left( position - 1, results, n, max_dist )             # <<<<<<<<<<<<<< 
 *         if len(results) == n: return results
 *         r = results
 */
  __pyx_1 = PyNumber_Subtract(__pyx_v_position, __pyx_int_1); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 254; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_5 = __pyx_PyInt_int(__pyx_1); if (unlikely((__pyx_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 254; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->__pyx_vtab)->_seek_left(__pyx_v_self, __pyx_5, __pyx_v_results, __pyx_v_n, __pyx_v_max_dist);

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":255
 *         # use start - 1 becuase .left() assumes strictly left-of
 *         self._seek_left( position - 1, results, n, max_dist )
 *         if len(results) == n: return results             # <<<<<<<<<<<<<< 
 *         r = results
 *         r.sort(key=operator.attrgetter('end'), reverse=True)
 */
  __pyx_6 = PyObject_Length(((PyObject *)__pyx_v_results)); if (unlikely(__pyx_6 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 255; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_7 = (__pyx_6 == __pyx_v_n);
  if (__pyx_7) {
    Py_INCREF(((PyObject *)__pyx_v_results));
    __pyx_r = ((PyObject *)__pyx_v_results);
    goto __pyx_L0;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":256
 *         self._seek_left( position - 1, results, n, max_dist )
 *         if len(results) == n: return results
 *         r = results             # <<<<<<<<<<<<<< 
 *         r.sort(key=operator.attrgetter('end'), reverse=True)
 *         return r[:n]
 */
  Py_INCREF(((PyObject *)__pyx_v_results));
  Py_DECREF(__pyx_v_r);
  __pyx_v_r = ((PyObject *)__pyx_v_results);

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":257
 *         if len(results) == n: return results
 *         r = results
 *         r.sort(key=operator.attrgetter('end'), reverse=True)             # <<<<<<<<<<<<<< 
 *         return r[:n]
 * 
 */
  __pyx_4 = PyObject_GetAttr(__pyx_v_r, __pyx_n_sort); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = PyDict_New(); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_3 = __Pyx_GetName(__pyx_m, __pyx_n_operator); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_1 = PyObject_GetAttr(__pyx_3, __pyx_n_attrgetter); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_3); __pyx_3 = 0;
  __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_INCREF(__pyx_n_end);
  PyTuple_SET_ITEM(__pyx_3, 0, __pyx_n_end);
  __pyx_8 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_3), NULL); if (unlikely(!__pyx_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(((PyObject *)__pyx_3)); __pyx_3 = 0;
  if (PyDict_SetItem(__pyx_2, __pyx_n_key, __pyx_8) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_8); __pyx_8 = 0;
  if (PyDict_SetItem(__pyx_2, __pyx_n_reverse, Py_True) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_1 = PyEval_CallObjectWithKeywords(__pyx_4, ((PyObject *)__pyx_empty_tuple), ((PyObject *)__pyx_2)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_4); __pyx_4 = 0;
  Py_DECREF(((PyObject *)__pyx_2)); __pyx_2 = 0;
  Py_DECREF(__pyx_1); __pyx_1 = 0;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":258
 *         r = results
 *         r.sort(key=operator.attrgetter('end'), reverse=True)
 *         return r[:n]             # <<<<<<<<<<<<<< 
 * 
 *     cpdef right(self, position, int n=1, int max_dist=2500):
 */
  __pyx_3 = PySequence_GetSlice(__pyx_v_r, 0, __pyx_v_n); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 258; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  Py_XDECREF(__pyx_8);
  __Pyx_AddTraceback("cintervaltree.IntervalNode.left");
  __pyx_r = 0;
  __pyx_L0:;
  Py_XDECREF(__pyx_v_results);
  Py_DECREF(__pyx_v_r);
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":245
 *     ##     return [left, right]
 *     
 *     cpdef left(self, position, int n=1, int max_dist=2500):             # <<<<<<<<<<<<<< 
 *         """
 *         find n features with a start > than `position`
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_left(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalNode_left[] = "\n        find n features with a start > than `position`\n        f: a Interval object (or anything with an `end` attribute)\n        n: the number of features to return\n        max_dist: the maximum distance to look before giving up.\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_left(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_position = 0;
  int __pyx_v_n;
  int __pyx_v_max_dist;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  static char *__pyx_argnames[] = {"position","n","max_dist",0};
  __pyx_v_n = 1;
  __pyx_v_max_dist = 2500;
  if (likely(!__pyx_kwds) && likely(1 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 3)) {
    __pyx_v_position = PyTuple_GET_ITEM(__pyx_args, 0);
    if (PyTuple_GET_SIZE(__pyx_args) > 1) {
      __pyx_v_n = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_n == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L2;}
      if (PyTuple_GET_SIZE(__pyx_args) > 2) {
        __pyx_v_max_dist = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 2)); if (unlikely((__pyx_v_max_dist == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L2;}
      }
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "O|ii", __pyx_argnames, &__pyx_v_position, &__pyx_v_n, &__pyx_v_max_dist))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalNode.left");
  return NULL;
  __pyx_L3:;
  __pyx_1 = (__pyx_skip_dispatch = 1, ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->__pyx_vtab)->left(((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self), __pyx_v_position, ((void *)&((struct __pyx_opt_args_13cintervaltree_12IntervalNode_left){2,__pyx_v_n,__pyx_v_max_dist})))); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  __Pyx_AddTraceback("cintervaltree.IntervalNode.left");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":260
 *         return r[:n]
 * 
 *     cpdef right(self, position, int n=1, int max_dist=2500):             # <<<<<<<<<<<<<< 
 *         """
 *         find n features with a end < than position
 */

static PyObject *__pyx_n_start;


static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_right(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static  PyObject *__pyx_f_13cintervaltree_12IntervalNode_right(struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_self, PyObject *__pyx_v_position, struct __pyx_opt_args_13cintervaltree_12IntervalNode_right *__pyx_optional_args) {
  int __pyx_v_n = 1;
  int __pyx_v_max_dist = 2500;
  PyObject *__pyx_v_results = 0;
  PyObject *__pyx_v_r;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  int __pyx_5;
  Py_ssize_t __pyx_6 = 0;
  int __pyx_7;
  PyObject *__pyx_8 = 0;
  if (__pyx_optional_args) {
    if (__pyx_optional_args->__pyx_n > 0) {
      __pyx_v_n = __pyx_optional_args->n;
      if (__pyx_optional_args->__pyx_n > 1) {
        __pyx_v_max_dist = __pyx_optional_args->max_dist;
      }
    }
  }
  __pyx_v_r = Py_None; Py_INCREF(Py_None);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) __pyx_skip_dispatch = 0;
  /* Check if overriden in Python */
  else if (unlikely(((PyObject *)__pyx_v_self)->ob_type->tp_dictoffset != 0)) {
    __pyx_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_right); if (unlikely(!((PyObject *)__pyx_v_self))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1;}
    if (!(strcmp(__pyx_1->ob_type->tp_name, "builtin_function_or_method") == 0) || (PyCFunction_GET_FUNCTION(__pyx_1) != (void *)&__pyx_pf_13cintervaltree_12IntervalNode_right)) {
      __pyx_2 = PyInt_FromLong(__pyx_v_n); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_3 = PyInt_FromLong(__pyx_v_max_dist); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_4 = PyTuple_New(3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_INCREF(__pyx_v_position);
      PyTuple_SET_ITEM(__pyx_4, 0, __pyx_v_position);
      PyTuple_SET_ITEM(__pyx_4, 1, __pyx_2);
      PyTuple_SET_ITEM(__pyx_4, 2, __pyx_3);
      __pyx_2 = 0;
      __pyx_3 = 0;
      __pyx_2 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_4), NULL); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(__pyx_1); __pyx_1 = 0;
      Py_DECREF(((PyObject *)__pyx_4)); __pyx_4 = 0;
      __pyx_r = __pyx_2;
      __pyx_2 = 0;
      goto __pyx_L0;
    }
  }

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":267
 *         max_dist: the maximum distance to look before giving up.
 *         """
 *         cdef list results = []             # <<<<<<<<<<<<<< 
 *         # use end + 1 becuase .right() assumes strictly right-of
 *         self._seek_right(position + 1, results, n, max_dist)
 */
  __pyx_3 = PyList_New(0); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 267; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_v_results = __pyx_3;
  __pyx_3 = 0;


  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":269
 *         cdef list results = []
 *         # use end + 1 becuase .right() assumes strictly right-of
 *         self._seek_right(position + 1, results, n, max_dist)             # <<<<<<<<<<<<<< 
 *         if len(results) == n: return results
 *         r = results
 */
  __pyx_1 = PyNumber_Add(__pyx_v_position, __pyx_int_1); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 269; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_5 = __pyx_PyInt_int(__pyx_1); if (unlikely((__pyx_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 269; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->__pyx_vtab)->_seek_right(__pyx_v_self, __pyx_5, __pyx_v_results, __pyx_v_n, __pyx_v_max_dist);

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":270
 *         # use end + 1 becuase .right() assumes strictly right-of
 *         self._seek_right(position + 1, results, n, max_dist)
 *         if len(results) == n: return results             # <<<<<<<<<<<<<< 
 *         r = results
 *         r.sort(key=operator.attrgetter('start'))
 */
  __pyx_6 = PyObject_Length(((PyObject *)__pyx_v_results)); if (unlikely(__pyx_6 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_7 = (__pyx_6 == __pyx_v_n);
  if (__pyx_7) {
    Py_INCREF(((PyObject *)__pyx_v_results));
    __pyx_r = ((PyObject *)__pyx_v_results);
    goto __pyx_L0;
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":271
 *         self._seek_right(position + 1, results, n, max_dist)
 *         if len(results) == n: return results
 *         r = results             # <<<<<<<<<<<<<< 
 *         r.sort(key=operator.attrgetter('start'))
 *         return r[:n]
 */
  Py_INCREF(((PyObject *)__pyx_v_results));
  Py_DECREF(__pyx_v_r);
  __pyx_v_r = ((PyObject *)__pyx_v_results);

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":272
 *         if len(results) == n: return results
 *         r = results
 *         r.sort(key=operator.attrgetter('start'))             # <<<<<<<<<<<<<< 
 *         return r[:n]
 * 
 */
  __pyx_4 = PyObject_GetAttr(__pyx_v_r, __pyx_n_sort); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = PyDict_New(); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_3 = __Pyx_GetName(__pyx_m, __pyx_n_operator); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_1 = PyObject_GetAttr(__pyx_3, __pyx_n_attrgetter); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_3); __pyx_3 = 0;
  __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_INCREF(__pyx_n_start);
  PyTuple_SET_ITEM(__pyx_3, 0, __pyx_n_start);
  __pyx_8 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_3), NULL); if (unlikely(!__pyx_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(((PyObject *)__pyx_3)); __pyx_3 = 0;
  if (PyDict_SetItem(__pyx_2, __pyx_n_key, __pyx_8) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_8); __pyx_8 = 0;
  __pyx_1 = PyEval_CallObjectWithKeywords(__pyx_4, ((PyObject *)__pyx_empty_tuple), ((PyObject *)__pyx_2)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 272; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_4); __pyx_4 = 0;
  Py_DECREF(((PyObject *)__pyx_2)); __pyx_2 = 0;
  Py_DECREF(__pyx_1); __pyx_1 = 0;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":273
 *         r = results
 *         r.sort(key=operator.attrgetter('start'))
 *         return r[:n]             # <<<<<<<<<<<<<< 
 * 
 *     def traverse(self, func):
 */
  __pyx_3 = PySequence_GetSlice(__pyx_v_r, 0, __pyx_v_n); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 273; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  Py_XDECREF(__pyx_8);
  __Pyx_AddTraceback("cintervaltree.IntervalNode.right");
  __pyx_r = 0;
  __pyx_L0:;
  Py_XDECREF(__pyx_v_results);
  Py_DECREF(__pyx_v_r);
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":260
 *         return r[:n]
 * 
 *     cpdef right(self, position, int n=1, int max_dist=2500):             # <<<<<<<<<<<<<< 
 *         """
 *         find n features with a end < than position
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_right(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalNode_right[] = "\n        find n features with a end < than position\n        f: a Interval object (or anything with a `start` attribute)\n        n: the number of features to return\n        max_dist: the maximum distance to look before giving up.\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_right(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_position = 0;
  int __pyx_v_n;
  int __pyx_v_max_dist;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  static char *__pyx_argnames[] = {"position","n","max_dist",0};
  __pyx_v_n = 1;
  __pyx_v_max_dist = 2500;
  if (likely(!__pyx_kwds) && likely(1 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 3)) {
    __pyx_v_position = PyTuple_GET_ITEM(__pyx_args, 0);
    if (PyTuple_GET_SIZE(__pyx_args) > 1) {
      __pyx_v_n = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_n == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L2;}
      if (PyTuple_GET_SIZE(__pyx_args) > 2) {
        __pyx_v_max_dist = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 2)); if (unlikely((__pyx_v_max_dist == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L2;}
      }
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "O|ii", __pyx_argnames, &__pyx_v_position, &__pyx_v_n, &__pyx_v_max_dist))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalNode.right");
  return NULL;
  __pyx_L3:;
  __pyx_1 = (__pyx_skip_dispatch = 1, ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->__pyx_vtab)->right(((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self), __pyx_v_position, ((void *)&((struct __pyx_opt_args_13cintervaltree_12IntervalNode_right){2,__pyx_v_n,__pyx_v_max_dist})))); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_r = __pyx_1;
  __pyx_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  __Pyx_AddTraceback("cintervaltree.IntervalNode.right");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":275
 *         return r[:n]
 * 
 *     def traverse(self, func):             # <<<<<<<<<<<<<< 
 *         self._traverse(func)
 * 
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_traverse(PyObject *__pyx_v_self, PyObject *__pyx_v_func); /*proto*/
static PyObject *__pyx_pf_13cintervaltree_12IntervalNode_traverse(PyObject *__pyx_v_self, PyObject *__pyx_v_func) {
  PyObject *__pyx_r;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":276
 * 
 *     def traverse(self, func):
 *         self._traverse(func)             # <<<<<<<<<<<<<< 
 * 
 *     cdef void _traverse(IntervalNode self, object func):
 */
  ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self)->__pyx_vtab)->_traverse(((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_v_self), __pyx_v_func);

  __pyx_r = Py_None; Py_INCREF(Py_None);
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":278
 *         self._traverse(func)
 * 
 *     cdef void _traverse(IntervalNode self, object func):             # <<<<<<<<<<<<<< 
 *         if self.cleft is not EmptyNode: self.cleft._traverse(func)
 *         func(self)
 */

static  void __pyx_f_13cintervaltree_12IntervalNode__traverse(struct __pyx_obj_13cintervaltree_IntervalNode *__pyx_v_self, PyObject *__pyx_v_func) {
  int __pyx_1;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":279
 * 
 *     cdef void _traverse(IntervalNode self, object func):
 *         if self.cleft is not EmptyNode: self.cleft._traverse(func)             # <<<<<<<<<<<<<< 
 *         func(self)
 *         if self.cright is not EmptyNode: self.cright._traverse(func)
 */
  __pyx_1 = (__pyx_v_self->cleft != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_1) {
    ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->cleft->__pyx_vtab)->_traverse(__pyx_v_self->cleft, __pyx_v_func);
    goto __pyx_L2;
  }
  __pyx_L2:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":280
 *     cdef void _traverse(IntervalNode self, object func):
 *         if self.cleft is not EmptyNode: self.cleft._traverse(func)
 *         func(self)             # <<<<<<<<<<<<<< 
 *         if self.cright is not EmptyNode: self.cright._traverse(func)
 * 
 */
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_INCREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_2, 0, ((PyObject *)__pyx_v_self));
  __pyx_3 = PyObject_Call(__pyx_v_func, ((PyObject *)__pyx_2), NULL); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(((PyObject *)__pyx_2)); __pyx_2 = 0;
  Py_DECREF(__pyx_3); __pyx_3 = 0;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":281
 *         if self.cleft is not EmptyNode: self.cleft._traverse(func)
 *         func(self)
 *         if self.cright is not EmptyNode: self.cright._traverse(func)             # <<<<<<<<<<<<<< 
 * 
 * cdef IntervalNode EmptyNode = IntervalNode( 0, 0, Interval(0, 0))
 */
  __pyx_1 = (__pyx_v_self->cright != __pyx_v_13cintervaltree_EmptyNode);
  if (__pyx_1) {
    ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)__pyx_v_self->cright->__pyx_vtab)->_traverse(__pyx_v_self->cright, __pyx_v_func);
    goto __pyx_L3;
  }
  __pyx_L3:;

  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_WriteUnraisable("cintervaltree.IntervalNode._traverse");
  __pyx_L0:;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":304
 *     cdef public object value, strand
 * 
 *     def __init__(self, int start, int end, object value=None, object strand=None ):             # <<<<<<<<<<<<<< 
 *         assert start <= end, "start must be less than end"
 *         self.start  = start
 */

static PyObject *__pyx_k_8p;

static char __pyx_k_8[] = "start must be less than end";

static int __pyx_pf_13cintervaltree_8Interval___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pf_13cintervaltree_8Interval___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_start;
  int __pyx_v_end;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_v_strand = 0;
  int __pyx_r;
  static char *__pyx_argnames[] = {"start","end","value","strand",0};
  __pyx_v_value = Py_None;
  __pyx_v_strand = Py_None;
  if (likely(!__pyx_kwds) && likely(2 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 4)) {
    __pyx_v_start = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_start == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 304; __pyx_clineno = __LINE__; goto __pyx_L2;}
    __pyx_v_end = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_end == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 304; __pyx_clineno = __LINE__; goto __pyx_L2;}
    if (PyTuple_GET_SIZE(__pyx_args) > 2) {
      __pyx_v_value = PyTuple_GET_ITEM(__pyx_args, 2);
      if (PyTuple_GET_SIZE(__pyx_args) > 3) {
        __pyx_v_strand = PyTuple_GET_ITEM(__pyx_args, 3);
      }
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "ii|OO", __pyx_argnames, &__pyx_v_start, &__pyx_v_end, &__pyx_v_value, &__pyx_v_strand))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 304; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.Interval.__init__");
  return -1;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":305
 * 
 *     def __init__(self, int start, int end, object value=None, object strand=None ):
 *         assert start <= end, "start must be less than end"             # <<<<<<<<<<<<<< 
 *         self.start  = start
 *         self.end   = end      
 */
  #ifndef PYREX_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_start <= __pyx_v_end))) {
    PyErr_SetObject(PyExc_AssertionError, __pyx_k_8p);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1;}
  }
  #endif

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":306
 *     def __init__(self, int start, int end, object value=None, object strand=None ):
 *         assert start <= end, "start must be less than end"
 *         self.start  = start             # <<<<<<<<<<<<<< 
 *         self.end   = end      
 *         self.value = value
 */
  ((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->start = __pyx_v_start;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":307
 *         assert start <= end, "start must be less than end"
 *         self.start  = start
 *         self.end   = end             # <<<<<<<<<<<<<< 
 *         self.value = value
 *         self.strand = strand
 */
  ((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->end = __pyx_v_end;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":308
 *         self.start  = start
 *         self.end   = end      
 *         self.value = value             # <<<<<<<<<<<<<< 
 *         self.strand = strand
 * 
 */
  Py_INCREF(__pyx_v_value);
  Py_DECREF(((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->value);
  ((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->value = __pyx_v_value;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":309
 *         self.end   = end      
 *         self.value = value
 *         self.strand = strand             # <<<<<<<<<<<<<< 
 * 
 *     def __repr__(self):
 */
  Py_INCREF(__pyx_v_strand);
  Py_DECREF(((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->strand);
  ((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->strand = __pyx_v_strand;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1:;
  __Pyx_AddTraceback("cintervaltree.Interval.__init__");
  __pyx_r = -1;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":311
 *         self.strand = strand
 * 
 *     def __repr__(self):             # <<<<<<<<<<<<<< 
 *         fstr = "Interval(%d, %d" % (self.start, self.end)
 *         if not self.value is None:
 */

static PyObject *__pyx_k_9p;
static PyObject *__pyx_k_10p;
static PyObject *__pyx_k_11p;

static char __pyx_k_9[] = "Interval(%d, %d";
static char __pyx_k_10[] = ", value=";
static char __pyx_k_11[] = ")";

static PyObject *__pyx_pf_13cintervaltree_8Interval___repr__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_13cintervaltree_8Interval___repr__(PyObject *__pyx_v_self) {
  PyObject *__pyx_v_fstr;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  int __pyx_4;
  int __pyx_5;
  __pyx_v_fstr = Py_None; Py_INCREF(Py_None);

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":312
 * 
 *     def __repr__(self):
 *         fstr = "Interval(%d, %d" % (self.start, self.end)             # <<<<<<<<<<<<<< 
 *         if not self.value is None:
 *             fstr += ", value=" + str(self.value)
 */
  __pyx_1 = PyInt_FromLong(((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->start); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 312; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = PyInt_FromLong(((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->end); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 312; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_3 = PyTuple_New(2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 312; __pyx_clineno = __LINE__; goto __pyx_L1;}
  PyTuple_SET_ITEM(__pyx_3, 0, __pyx_1);
  PyTuple_SET_ITEM(__pyx_3, 1, __pyx_2);
  __pyx_1 = 0;
  __pyx_2 = 0;
  __pyx_1 = PyNumber_Remainder(__pyx_k_9p, ((PyObject *)__pyx_3)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 312; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(((PyObject *)__pyx_3)); __pyx_3 = 0;
  Py_DECREF(__pyx_v_fstr);
  __pyx_v_fstr = __pyx_1;
  __pyx_1 = 0;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":313
 *     def __repr__(self):
 *         fstr = "Interval(%d, %d" % (self.start, self.end)
 *         if not self.value is None:             # <<<<<<<<<<<<<< 
 *             fstr += ", value=" + str(self.value)
 *         fstr += ")"
 */
  __pyx_4 = (((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->value == Py_None);
  __pyx_5 = (!__pyx_4);
  if (__pyx_5) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":314
 *         fstr = "Interval(%d, %d" % (self.start, self.end)
 *         if not self.value is None:
 *             fstr += ", value=" + str(self.value)             # <<<<<<<<<<<<<< 
 *         fstr += ")"
 *         return fstr
 */
    __pyx_3 = PyTuple_New(1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_INCREF(((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->value);
    PyTuple_SET_ITEM(__pyx_3, 0, ((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->value);
    __pyx_1 = PyObject_Call(((PyObject*)&PyString_Type), ((PyObject *)__pyx_3), NULL); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(((PyObject *)__pyx_3)); __pyx_3 = 0;
    __pyx_3 = PyNumber_Add(__pyx_k_10p, __pyx_1); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(__pyx_1); __pyx_1 = 0;
    __pyx_2 = PyNumber_InPlaceAdd(__pyx_v_fstr, __pyx_3); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    Py_DECREF(__pyx_v_fstr);
    __pyx_v_fstr = __pyx_2;
    __pyx_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":315
 *         if not self.value is None:
 *             fstr += ", value=" + str(self.value)
 *         fstr += ")"             # <<<<<<<<<<<<<< 
 *         return fstr
 * 
 */
  __pyx_1 = PyNumber_InPlaceAdd(__pyx_v_fstr, __pyx_k_11p); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_v_fstr);
  __pyx_v_fstr = __pyx_1;
  __pyx_1 = 0;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":316
 *             fstr += ", value=" + str(self.value)
 *         fstr += ")"
 *         return fstr             # <<<<<<<<<<<<<< 
 * 
 *     def __cmp__(self, other):
 */
  Py_INCREF(__pyx_v_fstr);
  __pyx_r = __pyx_v_fstr;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("cintervaltree.Interval.__repr__");
  __pyx_r = NULL;
  __pyx_L0:;
  Py_DECREF(__pyx_v_fstr);
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":318
 *         return fstr
 * 
 *     def __cmp__(self, other):             # <<<<<<<<<<<<<< 
 *         return cmp( self.start, other.start ) or cmp( self.end, other.end )
 * 
 */

static PyObject *__pyx_n_cmp;

static PyObject *__pyx_builtin_cmp;

static int __pyx_pf_13cintervaltree_8Interval___cmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_other); /*proto*/
static int __pyx_pf_13cintervaltree_8Interval___cmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_other) {
  int __pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  int __pyx_5;
  int __pyx_6;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":319
 * 
 *     def __cmp__(self, other):
 *         return cmp( self.start, other.start ) or cmp( self.end, other.end )             # <<<<<<<<<<<<<< 
 * 
 * cdef class IntervalTree:
 */
  __pyx_2 = PyInt_FromLong(((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->start); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_3 = PyObject_GetAttr(__pyx_v_other, __pyx_n_start); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_4 = PyTuple_New(2); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1;}
  PyTuple_SET_ITEM(__pyx_4, 0, __pyx_2);
  PyTuple_SET_ITEM(__pyx_4, 1, __pyx_3);
  __pyx_2 = 0;
  __pyx_3 = 0;
  __pyx_1 = PyObject_Call(__pyx_builtin_cmp, ((PyObject *)__pyx_4), NULL); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(((PyObject *)__pyx_4)); __pyx_4 = 0;
  __pyx_5 = __Pyx_PyObject_IsTrue(__pyx_1); if (unlikely(__pyx_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (!__pyx_5) {
    Py_DECREF(__pyx_1); __pyx_1 = 0;
    __pyx_2 = PyInt_FromLong(((struct __pyx_obj_13cintervaltree_Interval *)__pyx_v_self)->end); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_3 = PyObject_GetAttr(__pyx_v_other, __pyx_n_end); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_4 = PyTuple_New(2); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1;}
    PyTuple_SET_ITEM(__pyx_4, 0, __pyx_2);
    PyTuple_SET_ITEM(__pyx_4, 1, __pyx_3);
    __pyx_2 = 0;
    __pyx_3 = 0;
    __pyx_1 = PyObject_Call(__pyx_builtin_cmp, ((PyObject *)__pyx_4), NULL); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(((PyObject *)__pyx_4)); __pyx_4 = 0;
  }
  __pyx_6 = __pyx_PyInt_int(__pyx_1); if (unlikely((__pyx_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  __pyx_r = __pyx_6;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("cintervaltree.Interval.__cmp__");
  __pyx_r = -1;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":379
 *     cdef IntervalNode root
 *     
 *     def __cinit__( self ):             # <<<<<<<<<<<<<< 
 *         root = None
 *     
 */

static int __pyx_pf_13cintervaltree_12IntervalTree___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pf_13cintervaltree_12IntervalTree___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_root;
  int __pyx_r;
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleTooLong(0, PyTuple_GET_SIZE(__pyx_args));
    return -1;
  }
  if (unlikely(__pyx_kwds)) {
    if (unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
  }
  __pyx_v_root = Py_None; Py_INCREF(Py_None);

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":380
 *     
 *     def __cinit__( self ):
 *         root = None             # <<<<<<<<<<<<<< 
 *     
 *     # ---- Position based interfaces -----------------------------------------
 */
  Py_INCREF(Py_None);
  Py_DECREF(__pyx_v_root);
  __pyx_v_root = Py_None;

  __pyx_r = 0;
  Py_DECREF(__pyx_v_root);
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":384
 *     # ---- Position based interfaces -----------------------------------------
 *     
 *     def insert( self, int start, int end, object value=None ):             # <<<<<<<<<<<<<< 
 *         """
 *         Insert the interval [start,end) associated with value `value`.
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_insert(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalTree_insert[] = "\n        Insert the interval [start,end) associated with value `value`.\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_insert(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_start;
  int __pyx_v_end;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_r;
  int __pyx_1;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  static char *__pyx_argnames[] = {"start","end","value",0};
  __pyx_v_value = Py_None;
  if (likely(!__pyx_kwds) && likely(2 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 3)) {
    __pyx_v_start = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_start == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 384; __pyx_clineno = __LINE__; goto __pyx_L2;}
    __pyx_v_end = __pyx_PyInt_int(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_end == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 384; __pyx_clineno = __LINE__; goto __pyx_L2;}
    if (PyTuple_GET_SIZE(__pyx_args) > 2) {
      __pyx_v_value = PyTuple_GET_ITEM(__pyx_args, 2);
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "ii|O", __pyx_argnames, &__pyx_v_start, &__pyx_v_end, &__pyx_v_value))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 384; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalTree.insert");
  return NULL;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":388
 *         Insert the interval [start,end) associated with value `value`.
 *         """
 *         if self.root:             # <<<<<<<<<<<<<< 
 *             self.root = self.root.insert( start, end, value )
 *         else:
 */
  __pyx_1 = __Pyx_PyObject_IsTrue(((PyObject *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root)); if (unlikely(__pyx_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 388; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (__pyx_1) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":389
 *         """
 *         if self.root:
 *             self.root = self.root.insert( start, end, value )             # <<<<<<<<<<<<<< 
 *         else:
 *             self.root = IntervalNode( start, end, value )
 */
    __pyx_2 = ((PyObject *)((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root->__pyx_vtab)->insert(((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root, __pyx_v_start, __pyx_v_end, __pyx_v_value)); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 389; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(((PyObject *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root));
    ((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root = ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_2);
    __pyx_2 = 0;
    goto __pyx_L4;
  }
  /*else*/ {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":391
 *             self.root = self.root.insert( start, end, value )
 *         else:
 *             self.root = IntervalNode( start, end, value )             # <<<<<<<<<<<<<< 
 *         
 *     def find( self, start, end ):
 */
    __pyx_2 = PyInt_FromLong(__pyx_v_start); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 391; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_3 = PyInt_FromLong(__pyx_v_end); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 391; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_4 = PyTuple_New(3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 391; __pyx_clineno = __LINE__; goto __pyx_L1;}
    PyTuple_SET_ITEM(__pyx_4, 0, __pyx_2);
    PyTuple_SET_ITEM(__pyx_4, 1, __pyx_3);
    Py_INCREF(__pyx_v_value);
    PyTuple_SET_ITEM(__pyx_4, 2, __pyx_v_value);
    __pyx_2 = 0;
    __pyx_3 = 0;
    __pyx_2 = PyObject_Call(((PyObject*)__pyx_ptype_13cintervaltree_IntervalNode), ((PyObject *)__pyx_4), NULL); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 391; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(((PyObject *)__pyx_4)); __pyx_4 = 0;
    if (!(__Pyx_TypeTest(__pyx_2, __pyx_ptype_13cintervaltree_IntervalNode))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 391; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(((PyObject *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root));
    ((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root = ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_2);
    __pyx_2 = 0;
  }
  __pyx_L4:;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("cintervaltree.IntervalTree.insert");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":393
 *             self.root = IntervalNode( start, end, value )
 *         
 *     def find( self, start, end ):             # <<<<<<<<<<<<<< 
 *         """
 *         Return a sorted list of all intervals overlapping [start,end).
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_find(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalTree_find[] = "\n        Return a sorted list of all intervals overlapping [start,end).\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_find(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_start = 0;
  PyObject *__pyx_v_end = 0;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  static char *__pyx_argnames[] = {"start","end",0};
  if (likely(!__pyx_kwds) && likely(PyTuple_GET_SIZE(__pyx_args) == 2)) {
    __pyx_v_start = PyTuple_GET_ITEM(__pyx_args, 0);
    __pyx_v_end = PyTuple_GET_ITEM(__pyx_args, 1);
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "OO", __pyx_argnames, &__pyx_v_start, &__pyx_v_end))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 393; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalTree.find");
  return NULL;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":397
 *         Return a sorted list of all intervals overlapping [start,end).
 *         """
 *         return self.root.find( start, end )             # <<<<<<<<<<<<<< 
 *     
 *     def before( self, position, num_intervals=1, max_dist=2500 ):
 */
  __pyx_1 = PyObject_GetAttr(((PyObject *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root), __pyx_n_find); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(2); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_INCREF(__pyx_v_start);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_start);
  Py_INCREF(__pyx_v_end);
  PyTuple_SET_ITEM(__pyx_2, 1, __pyx_v_end);
  __pyx_3 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_2), NULL); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(((PyObject *)__pyx_2)); __pyx_2 = 0;
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("cintervaltree.IntervalTree.find");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":399
 *         return self.root.find( start, end )
 *     
 *     def before( self, position, num_intervals=1, max_dist=2500 ):             # <<<<<<<<<<<<<< 
 *         """
 *         Find `num_intervals` intervals that lie before `position` and are no
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_before(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalTree_before[] = "\n        Find `num_intervals` intervals that lie before `position` and are no\n        further than `max_dist` positions aways\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_before(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_position = 0;
  PyObject *__pyx_v_num_intervals = 0;
  PyObject *__pyx_v_max_dist = 0;
  PyObject *__pyx_r;
  int __pyx_1;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  static char *__pyx_argnames[] = {"position","num_intervals","max_dist",0};
  __pyx_v_num_intervals = __pyx_int_1;
  __pyx_v_max_dist = __pyx_int_2500;
  if (likely(!__pyx_kwds) && likely(1 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 3)) {
    __pyx_v_position = PyTuple_GET_ITEM(__pyx_args, 0);
    if (PyTuple_GET_SIZE(__pyx_args) > 1) {
      __pyx_v_num_intervals = PyTuple_GET_ITEM(__pyx_args, 1);
      if (PyTuple_GET_SIZE(__pyx_args) > 2) {
        __pyx_v_max_dist = PyTuple_GET_ITEM(__pyx_args, 2);
      }
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "O|OO", __pyx_argnames, &__pyx_v_position, &__pyx_v_num_intervals, &__pyx_v_max_dist))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 399; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalTree.before");
  return NULL;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":404
 *         further than `max_dist` positions aways
 *         """
 *         return self.root.left( position, num_intervals, max_dist )             # <<<<<<<<<<<<<< 
 * 
 *     def after( self, position, num_intervals=1, max_dist=2500 ):
 */
  __pyx_1 = __pyx_PyInt_int(__pyx_v_num_intervals); if (unlikely((__pyx_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 404; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = __pyx_PyInt_int(__pyx_v_max_dist); if (unlikely((__pyx_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 404; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_3 = ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root->__pyx_vtab)->left(((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root, __pyx_v_position, ((void *)&((struct __pyx_opt_args_13cintervaltree_12IntervalNode_left){2,__pyx_1,__pyx_2}))); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 404; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("cintervaltree.IntervalTree.before");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":406
 *         return self.root.left( position, num_intervals, max_dist )
 * 
 *     def after( self, position, num_intervals=1, max_dist=2500 ):             # <<<<<<<<<<<<<< 
 *         """
 *         Find `num_intervals` intervals that lie after `position` and are no
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_after(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalTree_after[] = "\n        Find `num_intervals` intervals that lie after `position` and are no\n        further than `max_dist` positions aways\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_after(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_position = 0;
  PyObject *__pyx_v_num_intervals = 0;
  PyObject *__pyx_v_max_dist = 0;
  PyObject *__pyx_r;
  int __pyx_1;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  static char *__pyx_argnames[] = {"position","num_intervals","max_dist",0};
  __pyx_v_num_intervals = __pyx_int_1;
  __pyx_v_max_dist = __pyx_int_2500;
  if (likely(!__pyx_kwds) && likely(1 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 3)) {
    __pyx_v_position = PyTuple_GET_ITEM(__pyx_args, 0);
    if (PyTuple_GET_SIZE(__pyx_args) > 1) {
      __pyx_v_num_intervals = PyTuple_GET_ITEM(__pyx_args, 1);
      if (PyTuple_GET_SIZE(__pyx_args) > 2) {
        __pyx_v_max_dist = PyTuple_GET_ITEM(__pyx_args, 2);
      }
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "O|OO", __pyx_argnames, &__pyx_v_position, &__pyx_v_num_intervals, &__pyx_v_max_dist))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalTree.after");
  return NULL;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":411
 *         further than `max_dist` positions aways
 *         """
 *         return self.root.right( position, num_intervals, max_dist )             # <<<<<<<<<<<<<< 
 * 
 *     # ---- Interval-like object based interfaces -----------------------------
 */
  __pyx_1 = __pyx_PyInt_int(__pyx_v_num_intervals); if (unlikely((__pyx_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 411; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = __pyx_PyInt_int(__pyx_v_max_dist); if (unlikely((__pyx_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 411; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_3 = ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root->__pyx_vtab)->right(((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root, __pyx_v_position, ((void *)&((struct __pyx_opt_args_13cintervaltree_12IntervalNode_right){2,__pyx_1,__pyx_2}))); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 411; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_r = __pyx_3;
  __pyx_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("cintervaltree.IntervalTree.after");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":415
 *     # ---- Interval-like object based interfaces -----------------------------
 * 
 *     def insert_interval( self, interval ):             # <<<<<<<<<<<<<< 
 *         """
 *         Insert an "interval" like object (one with at least start and end
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_insert_interval(PyObject *__pyx_v_self, PyObject *__pyx_v_interval); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalTree_insert_interval[] = "\n        Insert an \"interval\" like object (one with at least start and end\n        attributes)\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_insert_interval(PyObject *__pyx_v_self, PyObject *__pyx_v_interval) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":420
 *         attributes)
 *         """
 *         self.insert( interval.start, interval.end, interval )             # <<<<<<<<<<<<<< 
 * 
 *     def before_interval( self, interval, num_intervals=1, max_dist=2500 ):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_insert); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_start); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_3 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_end); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_4 = PyTuple_New(3); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1;}
  PyTuple_SET_ITEM(__pyx_4, 0, __pyx_2);
  PyTuple_SET_ITEM(__pyx_4, 1, __pyx_3);
  Py_INCREF(__pyx_v_interval);
  PyTuple_SET_ITEM(__pyx_4, 2, __pyx_v_interval);
  __pyx_2 = 0;
  __pyx_3 = 0;
  __pyx_2 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_4), NULL); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(((PyObject *)__pyx_4)); __pyx_4 = 0;
  Py_DECREF(__pyx_2); __pyx_2 = 0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("cintervaltree.IntervalTree.insert_interval");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":422
 *         self.insert( interval.start, interval.end, interval )
 * 
 *     def before_interval( self, interval, num_intervals=1, max_dist=2500 ):             # <<<<<<<<<<<<<< 
 *         """
 *         Find `num_intervals` intervals that lie completely before `interval`
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_before_interval(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalTree_before_interval[] = "\n        Find `num_intervals` intervals that lie completely before `interval`\n        and are no further than `max_dist` positions aways\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_before_interval(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_interval = 0;
  PyObject *__pyx_v_num_intervals = 0;
  PyObject *__pyx_v_max_dist = 0;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  int __pyx_2;
  int __pyx_3;
  PyObject *__pyx_4 = 0;
  static char *__pyx_argnames[] = {"interval","num_intervals","max_dist",0};
  __pyx_v_num_intervals = __pyx_int_1;
  __pyx_v_max_dist = __pyx_int_2500;
  if (likely(!__pyx_kwds) && likely(1 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 3)) {
    __pyx_v_interval = PyTuple_GET_ITEM(__pyx_args, 0);
    if (PyTuple_GET_SIZE(__pyx_args) > 1) {
      __pyx_v_num_intervals = PyTuple_GET_ITEM(__pyx_args, 1);
      if (PyTuple_GET_SIZE(__pyx_args) > 2) {
        __pyx_v_max_dist = PyTuple_GET_ITEM(__pyx_args, 2);
      }
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "O|OO", __pyx_argnames, &__pyx_v_interval, &__pyx_v_num_intervals, &__pyx_v_max_dist))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalTree.before_interval");
  return NULL;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":427
 *         and are no further than `max_dist` positions aways
 *         """
 *         return self.root.left( interval.start, num_intervals, max_dist )             # <<<<<<<<<<<<<< 
 * 
 *     def after_interval( self, interval, num_intervals=1, max_dist=2500 ):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_start); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 427; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = __pyx_PyInt_int(__pyx_v_num_intervals); if (unlikely((__pyx_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 427; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_3 = __pyx_PyInt_int(__pyx_v_max_dist); if (unlikely((__pyx_3 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 427; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_4 = ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root->__pyx_vtab)->left(((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root, __pyx_1, ((void *)&((struct __pyx_opt_args_13cintervaltree_12IntervalNode_left){2,__pyx_2,__pyx_3}))); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 427; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  __pyx_r = __pyx_4;
  __pyx_4 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("cintervaltree.IntervalTree.before_interval");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":429
 *         return self.root.left( interval.start, num_intervals, max_dist )
 * 
 *     def after_interval( self, interval, num_intervals=1, max_dist=2500 ):             # <<<<<<<<<<<<<< 
 *         """
 *         Find `num_intervals` intervals that lie comletey after `interval` and
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_after_interval(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalTree_after_interval[] = "\n        Find `num_intervals` intervals that lie comletey after `interval` and\n        are no further than `max_dist` positions aways\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_after_interval(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_interval = 0;
  PyObject *__pyx_v_num_intervals = 0;
  PyObject *__pyx_v_max_dist = 0;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  int __pyx_2;
  int __pyx_3;
  PyObject *__pyx_4 = 0;
  static char *__pyx_argnames[] = {"interval","num_intervals","max_dist",0};
  __pyx_v_num_intervals = __pyx_int_1;
  __pyx_v_max_dist = __pyx_int_2500;
  if (likely(!__pyx_kwds) && likely(1 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 3)) {
    __pyx_v_interval = PyTuple_GET_ITEM(__pyx_args, 0);
    if (PyTuple_GET_SIZE(__pyx_args) > 1) {
      __pyx_v_num_intervals = PyTuple_GET_ITEM(__pyx_args, 1);
      if (PyTuple_GET_SIZE(__pyx_args) > 2) {
        __pyx_v_max_dist = PyTuple_GET_ITEM(__pyx_args, 2);
      }
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "O|OO", __pyx_argnames, &__pyx_v_interval, &__pyx_v_num_intervals, &__pyx_v_max_dist))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 429; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalTree.after_interval");
  return NULL;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":434
 *         are no further than `max_dist` positions aways
 *         """
 *         return self.root.right( interval.end, num_intervals, max_dist )             # <<<<<<<<<<<<<< 
 * 
 *     def upstream_of_interval( self, interval, num_intervals=1, max_dist=2500 ):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_end); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = __pyx_PyInt_int(__pyx_v_num_intervals); if (unlikely((__pyx_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_3 = __pyx_PyInt_int(__pyx_v_max_dist); if (unlikely((__pyx_3 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_4 = ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root->__pyx_vtab)->right(((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root, __pyx_1, ((void *)&((struct __pyx_opt_args_13cintervaltree_12IntervalNode_right){2,__pyx_2,__pyx_3}))); if (unlikely(!__pyx_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  __pyx_r = __pyx_4;
  __pyx_4 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_4);
  __Pyx_AddTraceback("cintervaltree.IntervalTree.after_interval");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":436
 *         return self.root.right( interval.end, num_intervals, max_dist )
 * 
 *     def upstream_of_interval( self, interval, num_intervals=1, max_dist=2500 ):             # <<<<<<<<<<<<<< 
 *         """
 *         Find `num_intervals` intervals that lie completely upstream of
 */

static PyObject *__pyx_int_neg_1;

static PyObject *__pyx_n_strand;

static PyObject *__pyx_k_12p;

static char __pyx_k_12[] = "-";

static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_upstream_of_interval(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalTree_upstream_of_interval[] = "\n        Find `num_intervals` intervals that lie completely upstream of\n        `interval` and are no further than `max_dist` positions aways\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_upstream_of_interval(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_interval = 0;
  PyObject *__pyx_v_num_intervals = 0;
  PyObject *__pyx_v_max_dist = 0;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  int __pyx_3;
  int __pyx_4;
  int __pyx_5;
  static char *__pyx_argnames[] = {"interval","num_intervals","max_dist",0};
  __pyx_v_num_intervals = __pyx_int_1;
  __pyx_v_max_dist = __pyx_int_2500;
  if (likely(!__pyx_kwds) && likely(1 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 3)) {
    __pyx_v_interval = PyTuple_GET_ITEM(__pyx_args, 0);
    if (PyTuple_GET_SIZE(__pyx_args) > 1) {
      __pyx_v_num_intervals = PyTuple_GET_ITEM(__pyx_args, 1);
      if (PyTuple_GET_SIZE(__pyx_args) > 2) {
        __pyx_v_max_dist = PyTuple_GET_ITEM(__pyx_args, 2);
      }
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "O|OO", __pyx_argnames, &__pyx_v_interval, &__pyx_v_num_intervals, &__pyx_v_max_dist))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 436; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalTree.upstream_of_interval");
  return NULL;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":441
 *         `interval` and are no further than `max_dist` positions aways
 *         """
 *         if interval.strand == -1 or interval.strand == "-":             # <<<<<<<<<<<<<< 
 *             return self.root.right( interval.end, num_intervals, max_dist )
 *         else:
 */
  __pyx_2 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_strand); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_1 = PyObject_RichCompare(__pyx_2, __pyx_int_neg_1, Py_EQ); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  __pyx_3 = __Pyx_PyObject_IsTrue(__pyx_1); if (unlikely(__pyx_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (!__pyx_3) {
    Py_DECREF(__pyx_1); __pyx_1 = 0;
    __pyx_2 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_strand); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_1 = PyObject_RichCompare(__pyx_2, __pyx_k_12p, Py_EQ); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
  }
  __pyx_3 = __Pyx_PyObject_IsTrue(__pyx_1); if (unlikely(__pyx_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  if (__pyx_3) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":442
 *         """
 *         if interval.strand == -1 or interval.strand == "-":
 *             return self.root.right( interval.end, num_intervals, max_dist )             # <<<<<<<<<<<<<< 
 *         else:
 *             return self.root.left( interval.start, num_intervals, max_dist )
 */
    __pyx_2 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_end); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 442; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_4 = __pyx_PyInt_int(__pyx_v_num_intervals); if (unlikely((__pyx_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 442; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_5 = __pyx_PyInt_int(__pyx_v_max_dist); if (unlikely((__pyx_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 442; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_1 = ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root->__pyx_vtab)->right(((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root, __pyx_2, ((void *)&((struct __pyx_opt_args_13cintervaltree_12IntervalNode_right){2,__pyx_4,__pyx_5}))); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 442; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    __pyx_r = __pyx_1;
    __pyx_1 = 0;
    goto __pyx_L0;
    goto __pyx_L4;
  }
  /*else*/ {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":444
 *             return self.root.right( interval.end, num_intervals, max_dist )
 *         else:
 *             return self.root.left( interval.start, num_intervals, max_dist )             # <<<<<<<<<<<<<< 
 * 
 *     def downstream_of_interval( self, interval, num_intervals=1, max_dist=2500 ):
 */
    __pyx_2 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_start); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 444; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_4 = __pyx_PyInt_int(__pyx_v_num_intervals); if (unlikely((__pyx_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 444; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_5 = __pyx_PyInt_int(__pyx_v_max_dist); if (unlikely((__pyx_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 444; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_1 = ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root->__pyx_vtab)->left(((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root, __pyx_2, ((void *)&((struct __pyx_opt_args_13cintervaltree_12IntervalNode_left){2,__pyx_4,__pyx_5}))); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 444; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    __pyx_r = __pyx_1;
    __pyx_1 = 0;
    goto __pyx_L0;
  }
  __pyx_L4:;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  __Pyx_AddTraceback("cintervaltree.IntervalTree.upstream_of_interval");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":446
 *             return self.root.left( interval.start, num_intervals, max_dist )
 * 
 *     def downstream_of_interval( self, interval, num_intervals=1, max_dist=2500 ):             # <<<<<<<<<<<<<< 
 *         """
 *         Find `num_intervals` intervals that lie completely downstream of
 */

static PyObject *__pyx_k_13p;

static char __pyx_k_13[] = "-";

static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_downstream_of_interval(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalTree_downstream_of_interval[] = "\n        Find `num_intervals` intervals that lie completely downstream of\n        `interval` and are no further than `max_dist` positions aways\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_downstream_of_interval(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_interval = 0;
  PyObject *__pyx_v_num_intervals = 0;
  PyObject *__pyx_v_max_dist = 0;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  int __pyx_3;
  int __pyx_4;
  int __pyx_5;
  static char *__pyx_argnames[] = {"interval","num_intervals","max_dist",0};
  __pyx_v_num_intervals = __pyx_int_1;
  __pyx_v_max_dist = __pyx_int_2500;
  if (likely(!__pyx_kwds) && likely(1 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 3)) {
    __pyx_v_interval = PyTuple_GET_ITEM(__pyx_args, 0);
    if (PyTuple_GET_SIZE(__pyx_args) > 1) {
      __pyx_v_num_intervals = PyTuple_GET_ITEM(__pyx_args, 1);
      if (PyTuple_GET_SIZE(__pyx_args) > 2) {
        __pyx_v_max_dist = PyTuple_GET_ITEM(__pyx_args, 2);
      }
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "O|OO", __pyx_argnames, &__pyx_v_interval, &__pyx_v_num_intervals, &__pyx_v_max_dist))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 446; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalTree.downstream_of_interval");
  return NULL;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":451
 *         `interval` and are no further than `max_dist` positions aways
 *         """
 *         if interval.strand == -1 or interval.strand == "-":             # <<<<<<<<<<<<<< 
 *             return self.root.left( interval.start, num_intervals, max_dist )
 *         else:
 */
  __pyx_2 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_strand); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_1 = PyObject_RichCompare(__pyx_2, __pyx_int_neg_1, Py_EQ); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_2); __pyx_2 = 0;
  __pyx_3 = __Pyx_PyObject_IsTrue(__pyx_1); if (unlikely(__pyx_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (!__pyx_3) {
    Py_DECREF(__pyx_1); __pyx_1 = 0;
    __pyx_2 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_strand); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_1 = PyObject_RichCompare(__pyx_2, __pyx_k_13p, Py_EQ); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
  }
  __pyx_3 = __Pyx_PyObject_IsTrue(__pyx_1); if (unlikely(__pyx_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  if (__pyx_3) {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":452
 *         """
 *         if interval.strand == -1 or interval.strand == "-":
 *             return self.root.left( interval.start, num_intervals, max_dist )             # <<<<<<<<<<<<<< 
 *         else:
 *             return self.root.right( interval.end, num_intervals, max_dist )
 */
    __pyx_2 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_start); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_4 = __pyx_PyInt_int(__pyx_v_num_intervals); if (unlikely((__pyx_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_5 = __pyx_PyInt_int(__pyx_v_max_dist); if (unlikely((__pyx_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_1 = ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root->__pyx_vtab)->left(((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root, __pyx_2, ((void *)&((struct __pyx_opt_args_13cintervaltree_12IntervalNode_left){2,__pyx_4,__pyx_5}))); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    __pyx_r = __pyx_1;
    __pyx_1 = 0;
    goto __pyx_L0;
    goto __pyx_L4;
  }
  /*else*/ {

    /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":454
 *             return self.root.left( interval.start, num_intervals, max_dist )
 *         else:
 *             return self.root.right( interval.end, num_intervals, max_dist )             # <<<<<<<<<<<<<< 
 *     
 *     # ---- Old 'Intersecter' interface ----------------------------------------
 */
    __pyx_2 = PyObject_GetAttr(__pyx_v_interval, __pyx_n_end); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_4 = __pyx_PyInt_int(__pyx_v_num_intervals); if (unlikely((__pyx_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_5 = __pyx_PyInt_int(__pyx_v_max_dist); if (unlikely((__pyx_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_1 = ((struct __pyx_vtabstruct_13cintervaltree_IntervalNode *)((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root->__pyx_vtab)->right(((struct __pyx_obj_13cintervaltree_IntervalTree *)__pyx_v_self)->root, __pyx_2, ((void *)&((struct __pyx_opt_args_13cintervaltree_12IntervalNode_right){2,__pyx_4,__pyx_5}))); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1;}
    Py_DECREF(__pyx_2); __pyx_2 = 0;
    __pyx_r = __pyx_1;
    __pyx_1 = 0;
    goto __pyx_L0;
  }
  __pyx_L4:;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  __Pyx_AddTraceback("cintervaltree.IntervalTree.downstream_of_interval");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":458
 *     # ---- Old 'Intersecter' interface ----------------------------------------
 * 
 *     def add( self, start, end, value=None ):             # <<<<<<<<<<<<<< 
 *         """
 *         Synonym for `insert`.
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_add(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalTree_add[] = "\n        Synonym for `insert`.\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_add(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_start = 0;
  PyObject *__pyx_v_end = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;
  static char *__pyx_argnames[] = {"start","end","value",0};
  __pyx_v_value = Py_None;
  if (likely(!__pyx_kwds) && likely(2 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 3)) {
    __pyx_v_start = PyTuple_GET_ITEM(__pyx_args, 0);
    __pyx_v_end = PyTuple_GET_ITEM(__pyx_args, 1);
    if (PyTuple_GET_SIZE(__pyx_args) > 2) {
      __pyx_v_value = PyTuple_GET_ITEM(__pyx_args, 2);
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "OO|O", __pyx_argnames, &__pyx_v_start, &__pyx_v_end, &__pyx_v_value))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 458; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("cintervaltree.IntervalTree.add");
  return NULL;
  __pyx_L3:;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":462
 *         Synonym for `insert`.
 *         """
 *         self.insert( start, end, value )             # <<<<<<<<<<<<<< 
 *     
 *     def add_interval( self, interval ):
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_insert); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(3); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_INCREF(__pyx_v_start);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_start);
  Py_INCREF(__pyx_v_end);
  PyTuple_SET_ITEM(__pyx_2, 1, __pyx_v_end);
  Py_INCREF(__pyx_v_value);
  PyTuple_SET_ITEM(__pyx_2, 2, __pyx_v_value);
  __pyx_3 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_2), NULL); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(((PyObject *)__pyx_2)); __pyx_2 = 0;
  Py_DECREF(__pyx_3); __pyx_3 = 0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("cintervaltree.IntervalTree.add");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

/* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":464
 *         self.insert( start, end, value )
 *     
 *     def add_interval( self, interval ):             # <<<<<<<<<<<<<< 
 *         """
 *         Synonym for `insert_interval`.
 */

static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_add_interval(PyObject *__pyx_v_self, PyObject *__pyx_v_interval); /*proto*/
static char __pyx_doc_13cintervaltree_12IntervalTree_add_interval[] = "\n        Synonym for `insert_interval`.\n        ";
static PyObject *__pyx_pf_13cintervaltree_12IntervalTree_add_interval(PyObject *__pyx_v_self, PyObject *__pyx_v_interval) {
  PyObject *__pyx_r;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_3 = 0;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":468
 *         Synonym for `insert_interval`.
 *         """
 *         self.insert( interval )             # <<<<<<<<<<<<<< 
 *     
 * # For backward compatibility
 */
  __pyx_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_insert); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 468; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_2 = PyTuple_New(1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 468; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_INCREF(__pyx_v_interval);
  PyTuple_SET_ITEM(__pyx_2, 0, __pyx_v_interval);
  __pyx_3 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_2), NULL); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 468; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;
  Py_DECREF(((PyObject *)__pyx_2)); __pyx_2 = 0;
  Py_DECREF(__pyx_3); __pyx_3 = 0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  Py_XDECREF(__pyx_3);
  __Pyx_AddTraceback("cintervaltree.IntervalTree.add_interval");
  __pyx_r = NULL;
  __pyx_L0:;
  return __pyx_r;
}

static __Pyx_InternTabEntry __pyx_intern_tab[] = {
  {&__pyx_n_Intersecter, "Intersecter"},
  {&__pyx_n___cinit__, "__cinit__"},
  {&__pyx_n___cmp__, "__cmp__"},
  {&__pyx_n___init__, "__init__"},
  {&__pyx_n___repr__, "__repr__"},
  {&__pyx_n_add, "add"},
  {&__pyx_n_add_interval, "add_interval"},
  {&__pyx_n_after, "after"},
  {&__pyx_n_after_interval, "after_interval"},
  {&__pyx_n_attrgetter, "attrgetter"},
  {&__pyx_n_before, "before"},
  {&__pyx_n_before_interval, "before_interval"},
  {&__pyx_n_cmp, "cmp"},
  {&__pyx_n_downstream_of_interval, "downstream_of_interval"},
  {&__pyx_n_end, "end"},
  {&__pyx_n_find, "find"},
  {&__pyx_n_insert, "insert"},
  {&__pyx_n_insert_interval, "insert_interval"},
  {&__pyx_n_intersect, "intersect"},
  {&__pyx_n_key, "key"},
  {&__pyx_n_left, "left"},
  {&__pyx_n_operator, "operator"},
  {&__pyx_n_reverse, "reverse"},
  {&__pyx_n_right, "right"},
  {&__pyx_n_sort, "sort"},
  {&__pyx_n_start, "start"},
  {&__pyx_n_strand, "strand"},
  {&__pyx_n_traverse, "traverse"},
  {&__pyx_n_upstream_of_interval, "upstream_of_interval"},
  {0, 0}
};

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_k_2p, __pyx_k_2, sizeof(__pyx_k_2), 0},
  {&__pyx_k_8p, __pyx_k_8, sizeof(__pyx_k_8), 0},
  {&__pyx_k_9p, __pyx_k_9, sizeof(__pyx_k_9), 0},
  {&__pyx_k_10p, __pyx_k_10, sizeof(__pyx_k_10), 0},
  {&__pyx_k_11p, __pyx_k_11, sizeof(__pyx_k_11), 0},
  {&__pyx_k_12p, __pyx_k_12, sizeof(__pyx_k_12), 0},
  {&__pyx_k_13p, __pyx_k_13, sizeof(__pyx_k_13), 0},
  {0, 0, 0, 0}
};
static struct __pyx_vtabstruct_13cintervaltree_IntervalNode __pyx_vtable_13cintervaltree_IntervalNode;

static PyObject *__pyx_tp_new_13cintervaltree_IntervalNode(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_13cintervaltree_IntervalNode *p;
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  p = ((struct __pyx_obj_13cintervaltree_IntervalNode *)o);
  *(struct __pyx_vtabstruct_13cintervaltree_IntervalNode **)&p->__pyx_vtab = __pyx_vtabptr_13cintervaltree_IntervalNode;
  p->interval = Py_None; Py_INCREF(Py_None);
  p->cleft = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  p->cright = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  p->croot = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  if (__pyx_pf_13cintervaltree_12IntervalNode___cinit__(o, a, k) < 0) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_13cintervaltree_IntervalNode(PyObject *o) {
  struct __pyx_obj_13cintervaltree_IntervalNode *p = (struct __pyx_obj_13cintervaltree_IntervalNode *)o;
  Py_XDECREF(p->interval);
  Py_XDECREF(((PyObject *)p->cleft));
  Py_XDECREF(((PyObject *)p->cright));
  Py_XDECREF(((PyObject *)p->croot));
  (*o->ob_type->tp_free)(o);
}

static int __pyx_tp_traverse_13cintervaltree_IntervalNode(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_13cintervaltree_IntervalNode *p = (struct __pyx_obj_13cintervaltree_IntervalNode *)o;
  if (p->interval) {
    e = (*v)(p->interval, a); if (e) return e;
  }
  if (p->cleft) {
    e = (*v)(((PyObject*)p->cleft), a); if (e) return e;
  }
  if (p->cright) {
    e = (*v)(((PyObject*)p->cright), a); if (e) return e;
  }
  if (p->croot) {
    e = (*v)(((PyObject*)p->croot), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_13cintervaltree_IntervalNode(PyObject *o) {
  struct __pyx_obj_13cintervaltree_IntervalNode *p = (struct __pyx_obj_13cintervaltree_IntervalNode *)o;
  PyObject* tmp;
  tmp = ((PyObject*)p->interval);
  p->interval = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->cleft);
  p->cleft = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->cright);
  p->cright = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->croot);
  p->croot = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyObject *__pyx_getprop_13cintervaltree_12IntervalNode_left_node(PyObject *o, void *x) {
  return __pyx_pf_13cintervaltree_12IntervalNode_9left_node___get__(o);
}

static PyObject *__pyx_getprop_13cintervaltree_12IntervalNode_right_node(PyObject *o, void *x) {
  return __pyx_pf_13cintervaltree_12IntervalNode_10right_node___get__(o);
}

static PyObject *__pyx_getprop_13cintervaltree_12IntervalNode_root_node(PyObject *o, void *x) {
  return __pyx_pf_13cintervaltree_12IntervalNode_9root_node___get__(o);
}

static struct PyMethodDef __pyx_methods_13cintervaltree_IntervalNode[] = {
  {"__repr__", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalNode___repr__, METH_NOARGS|METH_COEXIST, 0},
  {"insert", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalNode_insert, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalNode_insert},
  {"intersect", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalNode_intersect, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalNode_intersect},
  {"left", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalNode_left, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalNode_left},
  {"right", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalNode_right, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalNode_right},
  {"traverse", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalNode_traverse, METH_O, 0},
  {0, 0, 0, 0}
};

static struct PyMemberDef __pyx_members_13cintervaltree_IntervalNode[] = {
  {"start", T_INT, offsetof(struct __pyx_obj_13cintervaltree_IntervalNode, start), 0, 0},
  {"end", T_INT, offsetof(struct __pyx_obj_13cintervaltree_IntervalNode, end), 0, 0},
  {0, 0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_13cintervaltree_IntervalNode[] = {
  {"left_node", __pyx_getprop_13cintervaltree_12IntervalNode_left_node, 0, 0, 0},
  {"right_node", __pyx_getprop_13cintervaltree_12IntervalNode_right_node, 0, 0, 0},
  {"root_node", __pyx_getprop_13cintervaltree_12IntervalNode_root_node, 0, 0, 0},
  {0, 0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_IntervalNode = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  0, /*nb_divide*/
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  0, /*nb_coerce*/
  0, /*nb_int*/
  0, /*nb_long*/
  0, /*nb_float*/
  0, /*nb_oct*/
  0, /*nb_hex*/
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  0, /*nb_inplace_divide*/
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if Py_TPFLAGS_DEFAULT & Py_TPFLAGS_HAVE_INDEX
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_IntervalNode = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_IntervalNode = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_IntervalNode = {
  0, /*bf_getreadbuffer*/
  0, /*bf_getwritebuffer*/
  0, /*bf_getsegcount*/
  0, /*bf_getcharbuffer*/
};

PyTypeObject __pyx_type_13cintervaltree_IntervalNode = {
  PyObject_HEAD_INIT(0)
  0, /*ob_size*/
  "cintervaltree.IntervalNode", /*tp_name*/
  sizeof(struct __pyx_obj_13cintervaltree_IntervalNode), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_13cintervaltree_IntervalNode, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  0, /*tp_compare*/
  __pyx_pf_13cintervaltree_12IntervalNode___repr__, /*tp_repr*/
  &__pyx_tp_as_number_IntervalNode, /*tp_as_number*/
  &__pyx_tp_as_sequence_IntervalNode, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_IntervalNode, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_IntervalNode, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    A single node of an `IntervalTree`.\n    \n    NOTE: Unless you really know what you are doing, you probably should us\n          `IntervalTree` rather than using this directly. \n    ", /*tp_doc*/
  __pyx_tp_traverse_13cintervaltree_IntervalNode, /*tp_traverse*/
  __pyx_tp_clear_13cintervaltree_IntervalNode, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_13cintervaltree_IntervalNode, /*tp_methods*/
  __pyx_members_13cintervaltree_IntervalNode, /*tp_members*/
  __pyx_getsets_13cintervaltree_IntervalNode, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_13cintervaltree_IntervalNode, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
};

static PyObject *__pyx_tp_new_13cintervaltree_Interval(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_13cintervaltree_Interval *p;
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  p = ((struct __pyx_obj_13cintervaltree_Interval *)o);
  p->value = Py_None; Py_INCREF(Py_None);
  p->strand = Py_None; Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_13cintervaltree_Interval(PyObject *o) {
  struct __pyx_obj_13cintervaltree_Interval *p = (struct __pyx_obj_13cintervaltree_Interval *)o;
  Py_XDECREF(p->value);
  Py_XDECREF(p->strand);
  (*o->ob_type->tp_free)(o);
}

static int __pyx_tp_traverse_13cintervaltree_Interval(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_13cintervaltree_Interval *p = (struct __pyx_obj_13cintervaltree_Interval *)o;
  if (p->value) {
    e = (*v)(p->value, a); if (e) return e;
  }
  if (p->strand) {
    e = (*v)(p->strand, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_13cintervaltree_Interval(PyObject *o) {
  struct __pyx_obj_13cintervaltree_Interval *p = (struct __pyx_obj_13cintervaltree_Interval *)o;
  PyObject* tmp;
  tmp = ((PyObject*)p->value);
  p->value = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->strand);
  p->strand = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static struct PyMethodDef __pyx_methods_13cintervaltree_Interval[] = {
  {"__repr__", (PyCFunction)__pyx_pf_13cintervaltree_8Interval___repr__, METH_NOARGS|METH_COEXIST, 0},
  {0, 0, 0, 0}
};

static struct PyMemberDef __pyx_members_13cintervaltree_Interval[] = {
  {"start", T_INT, offsetof(struct __pyx_obj_13cintervaltree_Interval, start), 0, 0},
  {"end", T_INT, offsetof(struct __pyx_obj_13cintervaltree_Interval, end), 0, 0},
  {"value", T_OBJECT, offsetof(struct __pyx_obj_13cintervaltree_Interval, value), 0, 0},
  {"strand", T_OBJECT, offsetof(struct __pyx_obj_13cintervaltree_Interval, strand), 0, 0},
  {0, 0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_Interval = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  0, /*nb_divide*/
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  0, /*nb_coerce*/
  0, /*nb_int*/
  0, /*nb_long*/
  0, /*nb_float*/
  0, /*nb_oct*/
  0, /*nb_hex*/
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  0, /*nb_inplace_divide*/
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if Py_TPFLAGS_DEFAULT & Py_TPFLAGS_HAVE_INDEX
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_Interval = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_Interval = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_Interval = {
  0, /*bf_getreadbuffer*/
  0, /*bf_getwritebuffer*/
  0, /*bf_getsegcount*/
  0, /*bf_getcharbuffer*/
};

PyTypeObject __pyx_type_13cintervaltree_Interval = {
  PyObject_HEAD_INIT(0)
  0, /*ob_size*/
  "cintervaltree.Interval", /*tp_name*/
  sizeof(struct __pyx_obj_13cintervaltree_Interval), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_13cintervaltree_Interval, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  __pyx_pf_13cintervaltree_8Interval___cmp__, /*tp_compare*/
  __pyx_pf_13cintervaltree_8Interval___repr__, /*tp_repr*/
  &__pyx_tp_as_number_Interval, /*tp_as_number*/
  &__pyx_tp_as_sequence_Interval, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_Interval, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_Interval, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Basic feature, with required integer start and end properties.\n    Also accpets optional strand as +1 or -1 (used for up/downstream queries),\n    a name, and any arbitrary data is sent in on the info keyword argument\n\n    >>> from bx.intervals.intersection import Interval\n\n    >>> f1 = Interval(23, 36)\n    >>> f2 = Interval(34, 48, value={\'chr\':12, \'anno\':\'transposon\'})\n    >>> f2\n    Interval(34, 48, value={\'anno\': \'transposon\', \'chr\': 12})\n\n    ", /*tp_doc*/
  __pyx_tp_traverse_13cintervaltree_Interval, /*tp_traverse*/
  __pyx_tp_clear_13cintervaltree_Interval, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_13cintervaltree_Interval, /*tp_methods*/
  __pyx_members_13cintervaltree_Interval, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pf_13cintervaltree_8Interval___init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_13cintervaltree_Interval, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
};

static PyObject *__pyx_tp_new_13cintervaltree_IntervalTree(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_13cintervaltree_IntervalTree *p;
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  p = ((struct __pyx_obj_13cintervaltree_IntervalTree *)o);
  p->root = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  if (__pyx_pf_13cintervaltree_12IntervalTree___cinit__(o, __pyx_empty_tuple, NULL) < 0) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_13cintervaltree_IntervalTree(PyObject *o) {
  struct __pyx_obj_13cintervaltree_IntervalTree *p = (struct __pyx_obj_13cintervaltree_IntervalTree *)o;
  Py_XDECREF(((PyObject *)p->root));
  (*o->ob_type->tp_free)(o);
}

static int __pyx_tp_traverse_13cintervaltree_IntervalTree(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_13cintervaltree_IntervalTree *p = (struct __pyx_obj_13cintervaltree_IntervalTree *)o;
  if (p->root) {
    e = (*v)(((PyObject*)p->root), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_13cintervaltree_IntervalTree(PyObject *o) {
  struct __pyx_obj_13cintervaltree_IntervalTree *p = (struct __pyx_obj_13cintervaltree_IntervalTree *)o;
  PyObject* tmp;
  tmp = ((PyObject*)p->root);
  p->root = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static struct PyMethodDef __pyx_methods_13cintervaltree_IntervalTree[] = {
  {"insert", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalTree_insert, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalTree_insert},
  {"find", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalTree_find, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalTree_find},
  {"before", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalTree_before, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalTree_before},
  {"after", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalTree_after, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalTree_after},
  {"insert_interval", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalTree_insert_interval, METH_O, __pyx_doc_13cintervaltree_12IntervalTree_insert_interval},
  {"before_interval", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalTree_before_interval, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalTree_before_interval},
  {"after_interval", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalTree_after_interval, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalTree_after_interval},
  {"upstream_of_interval", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalTree_upstream_of_interval, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalTree_upstream_of_interval},
  {"downstream_of_interval", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalTree_downstream_of_interval, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalTree_downstream_of_interval},
  {"add", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalTree_add, METH_VARARGS|METH_KEYWORDS, __pyx_doc_13cintervaltree_12IntervalTree_add},
  {"add_interval", (PyCFunction)__pyx_pf_13cintervaltree_12IntervalTree_add_interval, METH_O, __pyx_doc_13cintervaltree_12IntervalTree_add_interval},
  {0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_IntervalTree = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  0, /*nb_divide*/
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  0, /*nb_coerce*/
  0, /*nb_int*/
  0, /*nb_long*/
  0, /*nb_float*/
  0, /*nb_oct*/
  0, /*nb_hex*/
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  0, /*nb_inplace_divide*/
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if Py_TPFLAGS_DEFAULT & Py_TPFLAGS_HAVE_INDEX
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_IntervalTree = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_IntervalTree = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_IntervalTree = {
  0, /*bf_getreadbuffer*/
  0, /*bf_getwritebuffer*/
  0, /*bf_getsegcount*/
  0, /*bf_getcharbuffer*/
};

PyTypeObject __pyx_type_13cintervaltree_IntervalTree = {
  PyObject_HEAD_INIT(0)
  0, /*ob_size*/
  "cintervaltree.IntervalTree", /*tp_name*/
  sizeof(struct __pyx_obj_13cintervaltree_IntervalTree), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_13cintervaltree_IntervalTree, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  0, /*tp_compare*/
  0, /*tp_repr*/
  &__pyx_tp_as_number_IntervalTree, /*tp_as_number*/
  &__pyx_tp_as_sequence_IntervalTree, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_IntervalTree, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_IntervalTree, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Data structure for performing window intersect queries on a set of \n    of possibly overlapping 1d intervals.\n    \n    Usage\n    =====\n    \n    Create an empry IntervalTree\n    \n    >>> from bx.intervals.intersection import Interval, IntervalTree\n    >>> intersecter = IntervalTree()\n    \n    An interval is a start and end position and a value (possibly None).\n    You can add any object as an interval:\n    \n    >>> intersecter.insert( 0, 10, \"food\" )\n    >>> intersecter.insert( 3, 7, dict(foo=\'bar\') )\n    \n    >>> intersecter.find( 2, 5 )\n    [\'food\', {\'foo\': \'bar\'}]\n    \n    If the object has start and end attributes (like the Interval class) there\n    is are some shortcuts:\n    \n    >>> intersecter = IntervalTree()\n    >>> intersecter.insert_interval( Interval( 0, 10 ) )\n    >>> intersecter.insert_interval( Interval( 3, 7 ) )\n    >>> intersecter.insert_interval( Interval( 3, 40 ) )\n    >>> intersecter.insert_interval( Interval( 13, 50 ) )\n    \n    >>> intersecter.find( 30, 50 )\n    [Interval(3, 40), Interval(13, 50)]\n    >>> intersecter.find( 100, 200 )\n    []\n    \n    Before/after for intervals\n    \n    >>> intersecter.before_interval( Interval( 10, 20 ) )\n    [Interval(3, 7)]\n    >>> intersecter.before_interval( Interval( 5, 20 ) )\n    []\n    \n    Upstream/downstread\n    \n    >>> intersecter.upstream_of_interval(Interval(11, 12))\n    [Interval(0, 10)]\n    >>> intersecter.upstream_of_interval(Interval(11, 12, strand=\"-\"))\n    [Interval(13, 50)]\n\n    >>> intersecter.upstream_of_interval(Interval(1, 2, strand=\"-\"), num_intervals=3)\n    [Interval(3, 7), Interval(3, 40), Interval(13, 50)]\n\n    \n    ", /*tp_doc*/
  __pyx_tp_traverse_13cintervaltree_IntervalTree, /*tp_traverse*/
  __pyx_tp_clear_13cintervaltree_IntervalTree, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_13cintervaltree_IntervalTree, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_13cintervaltree_IntervalTree, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
};

static struct PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

static void __pyx_init_filenames(void); /*proto*/

PyMODINIT_FUNC initcintervaltree(void); /*proto*/
PyMODINIT_FUNC initcintervaltree(void) {
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  /*--- Libary function declarations ---*/
  __pyx_init_filenames();
  /*--- Module creation code ---*/
  __pyx_m = Py_InitModule4("cintervaltree", __pyx_methods, __pyx_mdoc, 0, PYTHON_API_VERSION);
  if (!__pyx_m) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  __pyx_b = PyImport_AddModule("__builtin__");
  if (!__pyx_b) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  /*--- Intern code ---*/
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  __pyx_int_2500 = PyInt_FromLong(2500); if (unlikely(!__pyx_int_2500)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  if (__Pyx_InternStrings(__pyx_intern_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  /*--- String init code ---*/
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  /*--- Builtin init code ---*/
  __pyx_builtin_cmp = __Pyx_GetName(__pyx_b, __pyx_n_cmp); if (!__pyx_builtin_cmp) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_skip_dispatch = 0;
  /*--- Global init code ---*/
  __pyx_v_13cintervaltree_EmptyNode = ((struct __pyx_obj_13cintervaltree_IntervalNode *)Py_None); Py_INCREF(Py_None);
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  __pyx_vtabptr_13cintervaltree_IntervalNode = &__pyx_vtable_13cintervaltree_IntervalNode;
  *(void(**)(void))&__pyx_vtable_13cintervaltree_IntervalNode.insert = (void(*)(void))__pyx_f_13cintervaltree_12IntervalNode_insert;
  *(void(**)(void))&__pyx_vtable_13cintervaltree_IntervalNode.rotate_right = (void(*)(void))__pyx_f_13cintervaltree_12IntervalNode_rotate_right;
  *(void(**)(void))&__pyx_vtable_13cintervaltree_IntervalNode.rotate_left = (void(*)(void))__pyx_f_13cintervaltree_12IntervalNode_rotate_left;
  *(void(**)(void))&__pyx_vtable_13cintervaltree_IntervalNode.set_ends = (void(*)(void))__pyx_f_13cintervaltree_12IntervalNode_set_ends;
  *(void(**)(void))&__pyx_vtable_13cintervaltree_IntervalNode._intersect = (void(*)(void))__pyx_f_13cintervaltree_12IntervalNode__intersect;
  *(void(**)(void))&__pyx_vtable_13cintervaltree_IntervalNode._seek_left = (void(*)(void))__pyx_f_13cintervaltree_12IntervalNode__seek_left;
  *(void(**)(void))&__pyx_vtable_13cintervaltree_IntervalNode._seek_right = (void(*)(void))__pyx_f_13cintervaltree_12IntervalNode__seek_right;
  *(void(**)(void))&__pyx_vtable_13cintervaltree_IntervalNode.left = (void(*)(void))__pyx_f_13cintervaltree_12IntervalNode_left;
  *(void(**)(void))&__pyx_vtable_13cintervaltree_IntervalNode.right = (void(*)(void))__pyx_f_13cintervaltree_12IntervalNode_right;
  *(void(**)(void))&__pyx_vtable_13cintervaltree_IntervalNode._traverse = (void(*)(void))__pyx_f_13cintervaltree_12IntervalNode__traverse;
  if (PyType_Ready(&__pyx_type_13cintervaltree_IntervalNode) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (__Pyx_SetVtable(__pyx_type_13cintervaltree_IntervalNode.tp_dict, __pyx_vtabptr_13cintervaltree_IntervalNode) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (PyObject_SetAttrString(__pyx_m, "IntervalNode", (PyObject *)&__pyx_type_13cintervaltree_IntervalNode) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_ptype_13cintervaltree_IntervalNode = &__pyx_type_13cintervaltree_IntervalNode;
  if (PyType_Ready(&__pyx_type_13cintervaltree_Interval) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (PyObject_SetAttrString(__pyx_m, "Interval", (PyObject *)&__pyx_type_13cintervaltree_Interval) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_ptype_13cintervaltree_Interval = &__pyx_type_13cintervaltree_Interval;
  if (PyType_Ready(&__pyx_type_13cintervaltree_IntervalTree) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 321; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (PyObject_SetAttrString(__pyx_m, "IntervalTree", (PyObject *)&__pyx_type_13cintervaltree_IntervalTree) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 321; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_ptype_13cintervaltree_IntervalTree = &__pyx_type_13cintervaltree_IntervalTree;
  /*--- Type import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":20
 * #    implement the same interface as the origianl Intersecter.
 * 
 * import operator             # <<<<<<<<<<<<<< 
 * 
 * cdef extern from "stdlib.h":
 */
  __pyx_1 = __Pyx_Import(__pyx_n_operator, 0); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (PyObject_SetAttr(__pyx_m, __pyx_n_operator, __pyx_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 20; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":58
 *     return a
 * 
 * cdef float nlog = -1.0 / log(0.5)             # <<<<<<<<<<<<<< 
 * 
 * cdef class IntervalNode:
 */
  __pyx_v_13cintervaltree_nlog = ((-1.0) / log(0.5));


  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":177
 *         return results
 * 
 *     find = intersect             # <<<<<<<<<<<<<< 
 *         
 *     cdef void _intersect( IntervalNode self, int start, int end, list results ):
 */
  __pyx_1 = __Pyx_GetName((PyObject *)__pyx_ptype_13cintervaltree_IntervalNode, __pyx_n_intersect); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 177; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (PyDict_SetItem((PyObject *)__pyx_ptype_13cintervaltree_IntervalNode->tp_dict, __pyx_n_find, __pyx_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 177; __pyx_clineno = __LINE__; goto __pyx_L1;}

  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":283
 *         if self.cright is not EmptyNode: self.cright._traverse(func)
 * 
 * cdef IntervalNode EmptyNode = IntervalNode( 0, 0, Interval(0, 0))             # <<<<<<<<<<<<<< 
 * 
 * ## ---- Wrappers that retain the old interface -------------------------------
 */
  __pyx_1 = PyTuple_New(2); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_INCREF(__pyx_int_0);
  PyTuple_SET_ITEM(__pyx_1, 0, __pyx_int_0);
  Py_INCREF(__pyx_int_0);
  PyTuple_SET_ITEM(__pyx_1, 1, __pyx_int_0);
  __pyx_2 = PyObject_Call(((PyObject*)__pyx_ptype_13cintervaltree_Interval), ((PyObject *)__pyx_1), NULL); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
  __pyx_1 = PyTuple_New(3); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_INCREF(__pyx_int_0);
  PyTuple_SET_ITEM(__pyx_1, 0, __pyx_int_0);
  Py_INCREF(__pyx_int_0);
  PyTuple_SET_ITEM(__pyx_1, 1, __pyx_int_0);
  PyTuple_SET_ITEM(__pyx_1, 2, __pyx_2);
  __pyx_2 = 0;
  __pyx_2 = PyObject_Call(((PyObject*)__pyx_ptype_13cintervaltree_IntervalNode), ((PyObject *)__pyx_1), NULL); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
  if (!(__Pyx_TypeTest(__pyx_2, __pyx_ptype_13cintervaltree_IntervalNode))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_v_13cintervaltree_EmptyNode = ((struct __pyx_obj_13cintervaltree_IntervalNode *)__pyx_2);
  __pyx_2 = 0;


  /* "/home/pzs/codetesters/pytesters/cintervaltree.pyx":471
 *     
 * # For backward compatibility
 * Intersecter = IntervalTree             # <<<<<<<<<<<<<< 
 */
  if (PyObject_SetAttr(__pyx_m, __pyx_n_Intersecter, ((PyObject*)__pyx_ptype_13cintervaltree_IntervalTree)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; __pyx_clineno = __LINE__; goto __pyx_L1;}
  return;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  Py_XDECREF(__pyx_2);
  __Pyx_AddTraceback("cintervaltree");
}

static char *__pyx_filenames[] = {
  "cintervaltree.pyx",
};

/* Runtime support code */

static void __pyx_init_filenames(void) {
  __pyx_f = __pyx_filenames;
}

static INLINE void __Pyx_RaiseArgtupleTooLong(
    Py_ssize_t num_expected,
    Py_ssize_t num_found)
{
    const char* error_message =
    #if PY_VERSION_HEX < 0x02050000
        "function takes at most %d positional arguments (%d given)";
    #else
        "function takes at most %zd positional arguments (%zd given)";
    #endif
    PyErr_Format(PyExc_TypeError, error_message, num_expected, num_found);
}

static int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        if (unlikely(!PyString_Check(key))) {
            PyErr_Format(PyExc_TypeError,
                         "%s() keywords must be strings", function_name);
            return 0;
        }
    }
    if (unlikely(!kw_allowed) && unlikely(key)) {
        PyErr_Format(PyExc_TypeError,
                     "'%s' is an invalid keyword argument for this function",
                     PyString_AsString(key));
        return 0;
    }
    return 1;
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list) {
    PyObject *__import__ = 0;
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    __import__ = PyObject_GetAttrString(__pyx_b, "__import__");
    if (!__import__)
        goto bad;
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    module = PyObject_CallFunction(__import__, "OOOO",
        name, global_dict, empty_dict, list);
bad:
    Py_XDECREF(empty_list);
    Py_XDECREF(__import__);
    Py_XDECREF(empty_dict);
    return module;
}

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
    PyObject *result;
    result = PyObject_GetAttr(dict, name);
    if (!result)
        PyErr_SetObject(PyExc_NameError, name);
    return result;
}

static int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (!type) {
        PyErr_Format(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (obj == Py_None || PyObject_TypeCheck(obj, type))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %s to %s",
        obj->ob_type->tp_name, type->tp_name);
    return 0;
}

static void __Pyx_WriteUnraisable(char *name) {
    PyObject *old_exc, *old_val, *old_tb;
    PyObject *ctx;
    PyErr_Fetch(&old_exc, &old_val, &old_tb);
    ctx = PyString_FromString(name);
    PyErr_Restore(old_exc, old_val, old_tb);
    if (!ctx)
        ctx = Py_None;
    PyErr_WriteUnraisable(ctx);
}

static int __Pyx_InternStrings(__Pyx_InternTabEntry *t) {
    while (t->p) {
        *t->p = PyString_InternFromString(t->s);
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
    PyObject *pycobj = 0;
    int result;
    
    pycobj = PyCObject_FromVoidPtr(vtable, 0);
    if (!pycobj)
        goto bad;
    if (PyDict_SetItemString(dict, "__pyx_vtable__", pycobj) < 0)
        goto bad;
    result = 0;
    goto done;

bad:
    result = -1;
done:
    Py_XDECREF(pycobj);
    return result;
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"

static void __Pyx_AddTraceback(char *funcname) {
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    PyObject *py_globals = 0;
    PyObject *empty_string = 0;
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    
    py_srcfile = PyString_FromString(__pyx_filename);
    if (!py_srcfile) goto bad;
    if (__pyx_clineno) {
        py_funcname = PyString_FromFormat( "%s (%s:%u)", funcname, __pyx_cfilenm, __pyx_clineno);
    }
    else {
        py_funcname = PyString_FromString(funcname);
    }
    if (!py_funcname) goto bad;
    py_globals = PyModule_GetDict(__pyx_m);
    if (!py_globals) goto bad;
    empty_string = PyString_FromString("");
    if (!empty_string) goto bad;
    py_code = PyCode_New(
        0,            /*int argcount,*/
        0,            /*int nlocals,*/
        0,            /*int stacksize,*/
        0,            /*int flags,*/
        empty_string, /*PyObject *code,*/
        __pyx_empty_tuple,  /*PyObject *consts,*/
        __pyx_empty_tuple,  /*PyObject *names,*/
        __pyx_empty_tuple,  /*PyObject *varnames,*/
        __pyx_empty_tuple,  /*PyObject *freevars,*/
        __pyx_empty_tuple,  /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        __pyx_lineno,   /*int firstlineno,*/
        empty_string  /*PyObject *lnotab*/
    );
    if (!py_code) goto bad;
    py_frame = PyFrame_New(
        PyThreadState_Get(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        py_globals,          /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = __pyx_lineno;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    Py_XDECREF(empty_string);
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* Type Conversion Functions */

static INLINE Py_ssize_t __pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject* x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}

static INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   if (x == Py_True) return 1;
   else if (x == Py_False) return 0;
   else return PyObject_IsTrue(x);
}

static INLINE PY_LONG_LONG __pyx_PyInt_AsLongLong(PyObject* x) {
    if (PyInt_CheckExact(x)) {
        return PyInt_AS_LONG(x);
    }
    else if (PyLong_CheckExact(x)) {
        return PyLong_AsLongLong(x);
    }
    else {
        PY_LONG_LONG val;
        PyObject* tmp = PyNumber_Int(x); if (!tmp) return (PY_LONG_LONG)-1;
        val = __pyx_PyInt_AsLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static INLINE unsigned PY_LONG_LONG __pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
    if (PyInt_CheckExact(x)) {
        long val = PyInt_AS_LONG(x);
        if (unlikely(val < 0)) {
            PyErr_SetString(PyExc_TypeError, "Negative assignment to unsigned type.");
            return (unsigned PY_LONG_LONG)-1;
        }
        return val;
    }
    else if (PyLong_CheckExact(x)) {
        return PyLong_AsUnsignedLongLong(x);
    }
    else {
        PY_LONG_LONG val;
        PyObject* tmp = PyNumber_Int(x); if (!tmp) return (PY_LONG_LONG)-1;
        val = __pyx_PyInt_AsUnsignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}


static INLINE unsigned char __pyx_PyInt_unsigned_char(PyObject* x) {
    if (sizeof(unsigned char) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        unsigned char val = (unsigned char)long_val;
        if (unlikely((val != long_val)  || (long_val < 0))) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to unsigned char");
            return (unsigned char)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE unsigned short __pyx_PyInt_unsigned_short(PyObject* x) {
    if (sizeof(unsigned short) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        unsigned short val = (unsigned short)long_val;
        if (unlikely((val != long_val)  || (long_val < 0))) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to unsigned short");
            return (unsigned short)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE char __pyx_PyInt_char(PyObject* x) {
    if (sizeof(char) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        char val = (char)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to char");
            return (char)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE short __pyx_PyInt_short(PyObject* x) {
    if (sizeof(short) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        short val = (short)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to short");
            return (short)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE int __pyx_PyInt_int(PyObject* x) {
    if (sizeof(int) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        int val = (int)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to int");
            return (int)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE long __pyx_PyInt_long(PyObject* x) {
    if (sizeof(long) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        long val = (long)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to long");
            return (long)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed char __pyx_PyInt_signed_char(PyObject* x) {
    if (sizeof(signed char) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed char val = (signed char)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed char");
            return (signed char)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed short __pyx_PyInt_signed_short(PyObject* x) {
    if (sizeof(signed short) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed short val = (signed short)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed short");
            return (signed short)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed int __pyx_PyInt_signed_int(PyObject* x) {
    if (sizeof(signed int) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed int val = (signed int)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed int");
            return (signed int)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed long __pyx_PyInt_signed_long(PyObject* x) {
    if (sizeof(signed long) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed long val = (signed long)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed long");
            return (signed long)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE long double __pyx_PyInt_long_double(PyObject* x) {
    if (sizeof(long double) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        long double val = (long double)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to long double");
            return (long double)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}
